<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>413. 等差数列划分-中等</title>
      <link href="2021/03/16/413-deng-chai-shu-lie-hua-fen-zhong-deng/"/>
      <url>2021/03/16/413-deng-chai-shu-lie-hua-fen-zhong-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h2><p>引用题解：<a href="https://github.com/changgyhub/leetcode_101">https://github.com/changgyhub/leetcode_101</a></p><pre><code class="line-numbers language-c++">1234123 234  1   2            1+2 = 312345123 234 345   1      2   3        1 + 2 + 3 = 6</code></pre><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p>输入是一个一维数组，输出是满足等差条件的连续字数组个数。</p><pre><code class="line-numbers language-c++">Input: nums = [1,2,3,4]Output: 3</code></pre><p>在这个样例中，等差数列有 [1,2,3]、[2,3,4] 和 [1,2,3,4]。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。</p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        if (n &lt; 3) return 0;        vector&lt;int&gt; dp(n, 0);        for (int i = 2; i &lt; n; ++i) &#123;            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) &#123;                dp[i] = dp[i-1] + 1;            &#125;        &#125;        return accumulate(dp.begin(), dp.end(), 0);    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198.打家劫舍-中等</title>
      <link href="2021/03/16/198-da-jia-jie-she-zhong-deng/"/>
      <url>2021/03/16/198-da-jia-jie-she-zhong-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol><li><p>动态规划 <code>dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])。</code></p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        //  dp ---0, 1, 2, 3, 4, 5 ... ---        //nums ---   0, 1, 2, 3, 4 ... ---        if (nums.empty()) return 0;        int n = nums.size();        vector&lt;int&gt; dp(n + 1, 0);        dp[1] = nums[0];        for (int i = 2; i &lt;= n; ++i) &#123;            dp[i] = max(dp[i-1], nums[i-1] + dp[i-2]);        &#125;        return dp[n];    &#125;&#125;;</code></pre></li><li><p>进行空间压缩</p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        // cur ---0, 1, 2, 3, 4, 5 ... ---        //nums ---   0, 1, 2, 3, 4 ... ---        if (nums.empty()) return 0;        int n = nums.size();        int pre1 = 0, pre2 = nums[0], cur;        for (int i = 1; i &lt; n; ++i) &#123;            cur = max(pre2, pre1 + nums[i]);            pre1 = pre2;            pre2 = cur;        &#125;        return cur;    &#125;&#125;;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70.爬楼梯-简单</title>
      <link href="2021/03/16/70-pa-lou-ti-jian-dan/"/>
      <url>2021/03/16/70-pa-lou-ti-jian-dan/</url>
      
        <content type="html"><![CDATA[<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h2><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="斐波那契数列百度百科："><a href="#斐波那契数列百度百科：" class="headerlink" title="斐波那契数列百度百科："></a>斐波那契数列百度百科：</h4><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：<code>0、1、1、2、3、5、8、13、21、34、……</code>在数学上，斐波那契数列以如下被以递推的方法定义：<code>F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）</code>在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><h4 id="典型的斐波那契数列，采用动态规划"><a href="#典型的斐波那契数列，采用动态规划" class="headerlink" title="典型的斐波那契数列，采用动态规划"></a>典型的斐波那契数列，采用动态规划</h4><ol><li><p>数组，空间复杂度为 O(n）</p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int climbStairs(int n) &#123;        //从F(0)=1，F(1)=1，开始        // n---0、1、2、3、4、5、 6、 7、 8---        //dp---1、1、2、3、5、8、13、21、34---        if (n &lt;= 2) return n;        vector&lt;int&gt; dp(n+1, 1);        for (int i = 2; i &lt;= n; ++i) &#123;            dp[i] = dp[i-1] + dp[i-2];        &#125;        return dp[n];    &#125;&#125;;</code></pre></li><li><p>空间压缩，空间复杂度优化为 O(1) </p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int climbStairs(int n) &#123;        //典型的斐波那契数列        //  n---0、1、2、3、4、5、 6、 7、 8---        //cur---1、1、2、3、5、8、13、21、34---        if (n &lt;= 2) return n;        int pre2 = 1, pre1 = 1, cur;        for (int i = 2; i &lt;= n; ++i) &#123;            cur = pre1 + pre2;            pre1 = pre2;            pre2 = cur;         &#125;        return cur;    &#125;&#125;;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="2021/03/16/linux-chang-yong-ming-ling/"/>
      <url>2021/03/16/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙命令"><a href="#防火墙命令" class="headerlink" title="防火墙命令"></a>防火墙命令</h2><pre><code class="line-numbers language-shell"># 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all # 查看全部信息firewall-cmd --list-ports # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=8080/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效</code></pre><h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><blockquote><ul><li><p>/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录一般该目录名是以用户的账号命名的。</p></li><li><p>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>/tmp：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，安装包！</p></li><li><p>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker进阶</title>
      <link href="2021/03/15/docker-jin-jie/"/>
      <url>2021/03/15/docker-jin-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="1-概述（官方文档）"><a href="#1-概述（官方文档）" class="headerlink" title="1.概述（官方文档）"></a>1.概述（官方文档）</h2><blockquote><p><strong>Looking for Compose file reference?</strong> <a href="https://docs.docker.com/compose/compose-file/">Find the latest version here</a>.</p></blockquote><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases">Common Use Cases</a>.</p><p>Using Compose is basically a three-step process:</p><ol><li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li>Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/cli-command/">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li></ol><p>A <code>docker-compose.yml</code> looks like this:</p><pre><code class="line-numbers language-yml">version: &quot;3.9&quot;  # optional since v1.27.0services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code      - logvolume01:/var/log    links:      - redis  redis:    image: redisvolumes:  logvolume01: &#123;&#125;</code></pre><p>For more information about the Compose file, see the <a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a>.</p><p>Compose has commands for managing the whole lifecycle of your application:</p><ul><li>Start, stop, and rebuild services</li><li>View the status of running services</li><li>Stream the log output of running services</li><li>Run a one-off command on a service</li></ul><p>关键词提取：</p><ul><li><p>multi-container Docker applications</p></li><li><p>use a YAML file to configure</p></li><li><p>with a single command</p></li></ul><p>概括：使用yml文件通过单个命令执行多个服务、容器、应用。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><ol><li><p>官网地址 </p><pre><code class="line-numbers language-shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.28.5/docker-        compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></pre></li><li><p>国内镜像</p><pre><code class="line-numbers language-shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-        compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre></li></ol><p><img src="/2021/03/15/docker-jin-jie/image-20210315185018091.png" alt="image-20210315185018091"></p><ol start="3"><li><p>授权</p><pre><code class="line-numbers language-shell">chmod +x /usr/local/bin/docker-compose</code></pre></li><li><p>查看版本</p><pre><code class="line-numbers language-shell">docker-compose --version</code></pre></li></ol><h2 id="3-Get-started-with-Docker-Compose"><a href="#3-Get-started-with-Docker-Compose" class="headerlink" title="3.Get started with Docker Compose"></a>3.Get started with Docker Compose</h2><p><strong>官网很详细，直接跟着官网走</strong></p><p><em>Estimated reading time: 11 minutes</em></p><p>On this page you build a simple Python web application running on Docker Compose. The application uses the Flask framework and maintains a hit counter in Redis. While the sample uses Python, the concepts demonstrated here should be understandable even if you’re not familiar with it.</p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p>Make sure you have already installed both <a href="https://docs.docker.com/get-docker/">Docker Engine</a> and <a href="https://docs.docker.com/compose/install/">Docker Compose</a>. You don’t need to install Python or Redis, as both are provided by Docker images.</p><h4 id="Step-1-Setup"><a href="#Step-1-Setup" class="headerlink" title="Step 1: Setup"></a>Step 1: Setup</h4><p>Define the application dependencies.</p><ol><li><p>Create a directory for the project:</p><pre><code class="line-numbers language-shell">$ mkdir composetest$ cd composetest</code></pre></li><li><p>Create a file called <code>app.py</code> in your project directory and paste this in:</p><pre><code class="line-numbers language-shell">import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#39;redis&#39;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#39;hits&#39;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#39;/&#39;)def hello():    count = get_hit_count()    return &#39;Hello World! I have been seen &#123;&#125; times.\n&#39;.format(count)</code></pre><p>In this example, <code>redis</code> is the hostname of the redis container on the application’s network. We use the default port for Redis, <code>6379</code>.</p><blockquote><p>Handling transient errors</p><p>Note the way the <code>get_hit_count</code> function is written. This basic retry loop lets us attempt our request multiple times if the redis service is not available. This is useful at startup while the application comes online, but also makes our application more resilient if the Redis service needs to be restarted anytime during the app’s lifetime. In a cluster, this also helps handling momentary connection drops between nodes.</p></blockquote></li><li><p>Create another file called <code>requirements.txt</code> in your project directory and paste this in:</p><pre><code class="line-numbers language-shell">flaskredis</code></pre></li></ol><h4 id="Step-2-Create-a-Dockerfile"><a href="#Step-2-Create-a-Dockerfile" class="headerlink" title="Step 2: Create a Dockerfile"></a>Step 2: Create a Dockerfile</h4><p>In this step, you write a Dockerfile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself.</p><p>In your project directory, create a file named <code>Dockerfile</code> and paste the following:</p><pre><code class="line-numbers language-shell">FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtEXPOSE 5000COPY . .CMD [&quot;flask&quot;, &quot;run&quot;]</code></pre><p>This tells Docker to:</p><ul><li>Build an image starting with the Python 3.7 image.</li><li>Set the working directory to <code>/code</code>.</li><li>Set environment variables used by the <code>flask</code> command.</li><li>Install gcc and other dependencies</li><li>Copy <code>requirements.txt</code> and install the Python dependencies.</li><li>Add metadata to the image to describe that the container is listening on port 5000</li><li>Copy the current directory <code>.</code> in the project to the workdir <code>.</code> in the image.</li><li>Set the default command for the container to <code>flask run</code>.</li></ul><p>For more information on how to write Dockerfiles, see the <a href="https://docs.docker.com/develop/">Docker user guide</a> and the <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a>.</p><h4 id="Step-3-Define-services-in-a-Compose-file"><a href="#Step-3-Define-services-in-a-Compose-file" class="headerlink" title="Step 3: Define services in a Compose file"></a>Step 3: Define services in a Compose file</h4><p>Create a file called <code>docker-compose.yml</code> in your project directory and paste the following:</p><pre><code class="line-numbers language-shell">version: &quot;3.3&quot; #官方写的3.9，但是会报错，改成3.3。services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre><p>This Compose file defines two services: <code>web</code> and <code>redis</code>.</p><h4 id="Web-service"><a href="#Web-service" class="headerlink" title="Web service"></a>Web service</h4><p>The <code>web</code> service uses an image that’s built from the <code>Dockerfile</code> in the current directory. It then binds the container and the host machine to the exposed port, <code>5000</code>. This example service uses the default port for the Flask web server, <code>5000</code>.</p><h4 id="Redis-service"><a href="#Redis-service" class="headerlink" title="Redis service"></a>Redis service</h4><p>The <code>redis</code> service uses a public <a href="https://registry.hub.docker.com/_/redis/">Redis</a> image pulled from the Docker Hub registry.</p><h4 id="Step-4-Build-and-run-your-app-with-Compose"><a href="#Step-4-Build-and-run-your-app-with-Compose" class="headerlink" title="Step 4: Build and run your app with Compose"></a>Step 4: Build and run your app with Compose</h4><ol><li><p>From your project directory, start up your application by running <code>docker-compose up</code>.</p><pre><code class="line-numbers language-shell">$ docker-compose upCreating network &quot;composetest_default&quot; with the default driverCreating composetest_web_1 ...Creating composetest_redis_1 ...Creating composetest_web_1Creating composetest_redis_1 ... doneAttaching to composetest_web_1, composetest_redis_1web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)redis_1  | 1:C 17 Aug 22:11:10.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1  | 1:C 17 Aug 22:11:10.480 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just startedredis_1  | 1:C 17 Aug 22:11:10.480 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.confweb_1    |  * Restarting with statredis_1  | 1:M 17 Aug 22:11:10.483 * Running mode=standalone, port=6379.redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.web_1    |  * Debugger is active!redis_1  | 1:M 17 Aug 22:11:10.483 # Server initializedredis_1  | 1:M 17 Aug 22:11:10.483 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#39; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.web_1    |  * Debugger PIN: 330-787-903redis_1  | 1:M 17 Aug 22:11:10.483 * Ready to accept connections</code></pre><p>Compose pulls a Redis image, builds an image for your code, and starts the services you defined. In this case, the code is statically copied into the image at build time.</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001054382.png" alt="image-20210316001054382"></p></li><li><p>Enter <a href="http://localhost:5000/">http://localhost:5000/</a> in a browser to see the application running.</p><p>If you’re using Docker natively on Linux, Docker Desktop for Mac, or Docker Desktop for Windows, then the web app should now be listening on port 5000 on your Docker daemon host. Point your web browser to <a href="http://localhost:5000/">http://localhost:5000</a> to find the <code>Hello World</code> message. If this doesn’t resolve, you can also try <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a>.</p><p>If you’re using Docker Machine on a Mac or Windows, use <code>docker-machine ip MACHINE_VM</code> to get the IP address of your Docker host. Then, open <code>http://MACHINE_VM_IP:5000</code> in a browser.</p><p>You should see a message in your browser saying:</p><pre><code class="line-numbers language-shell">Hello World! I have been seen 1 times.</code></pre><p><img src="/2021/03/15/docker-jin-jie/quick-hello-world-1.png" alt="hello world in browser"></p></li><li><p>Refresh the page.</p><p>The number should increment.</p><pre><code class="line-numbers language-shell">Hello World! I have been seen 2 times.</code></pre><p><img src="/2021/03/15/docker-jin-jie/quick-hello-world-2.png" alt="hello world in browser"></p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001224217.png" alt="image-20210316001224217"></p></li><li><p>Switch to another terminal window, and type <code>docker image ls</code> to list local images.</p><p>Listing images at this point should return <code>redis</code> and <code>web</code>.</p><pre><code class="line-numbers language-shell">$ docker image lsREPOSITORY        TAG           IMAGE ID      CREATED        SIZEcomposetest_web   latest        e2c21aa48cc1  4 minutes ago  93.8MBpython            3.4-alpine    84e6077c7ab6  7 days ago     82.5MBredis             alpine        9d8fa9aa0e5b  3 weeks ago    27.5MB</code></pre><p>You can inspect images with <code>docker inspect &lt;tag or id&gt;</code>.</p></li><li><p>Stop the application, either by running <code>docker-compose down</code> from within your project directory in the second terminal, or by hitting CTRL+C in the original terminal where you started the app.</p></li></ol><h4 id="Step-5-Edit-the-Compose-file-to-add-a-bind-mount"><a href="#Step-5-Edit-the-Compose-file-to-add-a-bind-mount" class="headerlink" title="Step 5: Edit the Compose file to add a bind mount"></a>Step 5: Edit the Compose file to add a bind mount</h4><p>Edit <code>docker-compose.yml</code> in your project directory to add a <a href="https://docs.docker.com/storage/bind-mounts/">bind mount</a> for the <code>web</code> service:</p><pre><code class="line-numbers language-shell">version: &quot;3.9&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code    environment:      FLASK_ENV: development  redis:    image: &quot;redis:alpine&quot;</code></pre><p>The new <code>volumes</code> key mounts the project directory (current directory) on the host to <code>/code</code> inside the container, allowing you to modify the code on the fly, without having to rebuild the image. The <code>environment</code> key sets the <code>FLASK_ENV</code> environment variable, which tells <code>flask run</code> to run in development mode and reload the code on change. This mode should only be used in development.</p><h4 id="Step-6-Re-build-and-run-the-app-with-Compose"><a href="#Step-6-Re-build-and-run-the-app-with-Compose" class="headerlink" title="Step 6: Re-build and run the app with Compose"></a>Step 6: Re-build and run the app with Compose</h4><p>From your project directory, type <code>docker-compose up</code> to build the app with the updated Compose file, and run it.</p><pre><code class="line-numbers language-shell">$ docker-compose upCreating network &quot;composetest_default&quot; with the default driverCreating composetest_web_1 ...Creating composetest_redis_1 ...Creating composetest_web_1Creating composetest_redis_1 ... doneAttaching to composetest_web_1, composetest_redis_1web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)...</code></pre><p>Check the <code>Hello World</code> message in a web browser again, and refresh to see the count increment.</p><blockquote><p>Shared folders, volumes, and bind mounts</p><ul><li>If your project is outside of the <code>Users</code> directory (<code>cd ~</code>), then you need to share the drive or location of the Dockerfile and volume you are using. If you get runtime errors indicating an application file is not found, a volume mount is denied, or a service cannot start, try enabling file or drive sharing. Volume mounting requires shared drives for projects that live outside of <code>C:\Users</code> (Windows) or <code>/Users</code> (Mac), and is required for <em>any</em> project on Docker Desktop for Windows that uses <a href="https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers">Linux containers</a>. For more information, see <a href="https://docs.docker.com/docker-for-mac/#file-sharing">File sharing</a> on Docker for Mac, and the general examples on how to <a href="https://docs.docker.com/storage/volumes/">Manage data in containers</a>.</li><li>If you are using Oracle VirtualBox on an older Windows OS, you might encounter an issue with shared folders as described in this <a href="https://www.virtualbox.org/ticket/14920">VB trouble ticket</a>. Newer Windows systems meet the requirements for <a href="https://docs.docker.com/docker-for-windows/install/">Docker Desktop for Windows</a> and do not need VirtualBox.</li></ul></blockquote><h4 id="Step-7-Update-the-application"><a href="#Step-7-Update-the-application" class="headerlink" title="Step 7: Update the application"></a>Step 7: Update the application</h4><p>Because the application code is now mounted into the container using a volume, you can make changes to its code and see the changes instantly, without having to rebuild the image.</p><p>Change the greeting in <code>app.py</code> and save it. For example, change the <code>Hello World!</code> message to <code>Hello from Docker!</code>:</p><pre><code class="line-numbers language-shell">return &#39;Hello from Docker! I have been seen &#123;&#125; times.\n&#39;.format(count)</code></pre><p>Refresh the app in your browser. The greeting should be updated, and the counter should still be incrementing.</p><p><img src="/2021/03/15/docker-jin-jie/quick-hello-world-3.png" alt="hello world in browser"></p><h4 id="Step-8-Experiment-with-some-other-commands"><a href="#Step-8-Experiment-with-some-other-commands" class="headerlink" title="Step 8: Experiment with some other commands"></a>Step 8: Experiment with some other commands</h4><p>If you want to run your services in the background, you can pass the <code>-d</code> flag (for “detached” mode) to <code>docker-compose up</code> and use <code>docker-compose ps</code> to see what is currently running:</p><pre><code class="line-numbers language-shell">$ docker-compose up -dStarting composetest_redis_1...Starting composetest_web_1...$ docker-compose ps       Name                      Command               State           Ports         -------------------------------------------------------------------------------------composetest_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp              composetest_web_1     flask run                        Up      0.0.0.0:5000-&gt;5000/tcp</code></pre><p>The <code>docker-compose run</code> command allows you to run one-off commands for your services. For example, to see what environment variables are available to the <code>web</code> service:</p><pre><code class="line-numbers language-shell">$ docker-compose run web env</code></pre><p>See <code>docker-compose --help</code> to see other available commands. You can also install <a href="https://docs.docker.com/compose/completion/">command completion</a> for the bash and zsh shell, which also shows you available commands.</p><p>If you started Compose with <code>docker-compose up -d</code>, stop your services once you’ve finished with them:</p><pre><code class="line-numbers language-shell">$ docker-compose stop</code></pre><p>You can bring everything down, removing the containers entirely, with the <code>down</code> command. Pass <code>--volumes</code> to also remove the data volume used by the Redis container:</p><pre><code class="line-numbers language-shell">$ docker-compose down --volumes</code></pre><p>At this point, you have seen the basics of how Compose works.</p><h3 id="Where-to-go-next"><a href="#Where-to-go-next" class="headerlink" title="Where to go next"></a>Where to go next</h3><ul><li>Next, try the <a href="https://docs.docker.com/compose/samples-for-compose/">Sample apps with Compose</a></li><li><a href="https://docs.docker.com/compose/reference/">Explore the full list of Compose commands</a></li><li><a href="https://docs.docker.com/compose/compose-file/">Compose configuration file reference</a></li><li>To learn more about volumes and bind mounts, see <a href="https://docs.docker.com/storage/">Manage data in Docker</a></li></ul><p><a href="https://docs.docker.com/search/?q=documentation">documentation</a>, <a href="https://docs.docker.com/search/?q=docs">docs</a>, <a href="https://docs.docker.com/search/?q=docker">docker</a>, <a href="https://docs.docker.com/search/?q=compose">compose</a>, <a href="https://docs.docker.com/search/?q=orchestration">orchestration</a>, <a href="https://docs.docker.com/search/?q=containers">containers</a></p><h2 id="4-整个过程的理解："><a href="#4-整个过程的理解：" class="headerlink" title="4.整个过程的理解："></a>4.整个过程的理解：</h2><p>1、应用app.py<br>2、Dockerfile应用打包为镜像<br>3、Docker-compose yaml文件 (定义整个服务，需要的环境。web、redis)完整的上线服务!</p><p>4、启动compose 项目(docker-compose up)<br>流程:</p><p>1、创建网络<br>2、执行Docker-compose yaml</p><p>3、启动服务。<br>Docker-compose yaml<br>Creating composetest_web_1 … done    </p><p>Creating composetest_redis_1 … done</p><p>1、文件名composetest</p><p>2、服务</p><pre><code class="line-numbers language-shell">version: &quot;3.9&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre><p> 自动的默认规则?</p><pre><code class="line-numbers language-shell">docker images</code></pre><p>帮我们自动下载了</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001522283.png" alt="image-20210316001522283"></p><p>默认的服务名    文件名_服务名__num</p><p>多个服务器。集群。A B _num    副本数量</p><p>服务redis服务=&gt;4个副本。<br>集群状态。服务都不可能只有一个运行实例。弹性、10 HA高并发。kubectl service负载均衡。</p><p>3、网络规则</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001653394.png" alt="image-20210316001653394"></p><p>10个服务=&gt;项目(项目中的内容都在同个网络下。域名访问)</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001908298.png" alt="image-20210316001908298"></p><p>如果在同一个网络下，我们可以直接通过域名访问。</p><p>HA!(高可用)</p><h2 id="5-yaml规则"><a href="#5-yaml规则" class="headerlink" title="5.yaml规则"></a>5.yaml规则</h2><h3 id="docker-compose-yaml-核心！"><a href="#docker-compose-yaml-核心！" class="headerlink" title="docker-compose.yaml 核心！"></a>docker-compose.yaml 核心！</h3><pre><code class="line-numbers language-yaml"># 3层！version: &#39;&#39; # 版本service: # 服务    服务1: web        # 服务配置        images        build        network        ...    服务2: redis        # 服务配置        images        build        network        ...    ...# 其他配置 卷、网络、全局规则volumes:networks:config:</code></pre><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>一个容器可能会依赖另一个容器， 通过depends_on可以配置启动顺序</p><p><strong>即使设置了<code>depends_on</code>，那也只是控制容器开始启动的时间，不能控制容器启动完成的时间</strong></p><pre><code class="line-numbers language-yaml">version: &quot;3.9&quot;services:  web:    build: .    depends_on:      - db      - redis  redis:    image: redis  db:    image: postgres</code></pre><p>其他详情见官网：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><h2 id="6-DockerFile构建过程"><a href="#6-DockerFile构建过程" class="headerlink" title="6.DockerFile构建过程"></a>6.DockerFile构建过程</h2><p>基础知识：</p><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、#表示注释</p><p>4、每一个指令都会创建提交一个新的镜像曾，并提交！</p><p><img src="/2021/03/15/docker-jin-jie/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc" alt="img"></p><p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p><p>Docker镜像逐渐成企业交付的标准，必须要掌握！</p><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</p><h2 id="7-DockerFire的指令"><a href="#7-DockerFire的指令" class="headerlink" title="7.DockerFire的指令"></a>7.DockerFire的指令</h2><p><img src="/2021/03/15/docker-jin-jie/u=1722217816,1097532442&fm=11&gp=0.jpg" alt="img"></p><pre><code class="line-numbers language-dockerfile">FROM                # 基础镜像，一切从这里开始构建MAINTAINER            # 镜像是谁写的， 姓名+邮箱RUN                    # 镜像构建的时候需要运行的命令ADD                    # 步骤，例如tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR                # 镜像的工作目录VOLUME                # 挂载的目录EXPOSE                # 保留端口配置CMD                    # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。ENTRYPOINT            # 指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD                # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。COPY                # 类似ADD，将我们文件拷贝到镜像中ENV                    # 构建的时候设置环境变量！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo代码高亮问题解决</title>
      <link href="2021/03/15/hexo-dai-ma-gao-liang-wen-ti-jie-jue/"/>
      <url>2021/03/15/hexo-dai-ma-gao-liang-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我的个人博客采用的是闪烁之狐大佬的主题<a href="https://github.com/blinkfox/hexo-theme-matery">Matery</a></p><p>最近发现我的文章代码无法高亮，寻找原因许久，终于解决！</p><p>闪烁之狐大佬采用的代码高亮插件是<a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a>，我按照教程一步步来，但无法高亮，网上很多解决方案也试了，都没有解决问题。</p><p>最后找到一篇博客<a href="https://www.jianshu.com/p/f395d92a1110">Hexo博客：六、prism代码高亮</a>，终于解决了我的问题。</p><p>本博客主题为<a href="https://github.com/blinkfox/hexo-theme-matery">Matery</a>，上边解决问题的主题为next，不过问题不大，照葫芦画瓢，无非是文件位置和代码写法不一样。</p><p>开动！！！</p><h3 id="1-清除hexo-prism-plugin插件"><a href="#1-清除hexo-prism-plugin插件" class="headerlink" title="1. 清除hexo-prism-plugin插件"></a>1. 清除<a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a>插件</h3><ol><li><p>打开根目录下的<code>package.json</code>文件，删除</p><pre><code class="line-numbers language-shell">hexo-prism-plugin: &quot;^2.3.0&quot;,</code></pre></li><li><p>打开根目录下的<code>_config.yml</code>文件，删除</p><pre><code class="line-numbers language-shell">prism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:</code></pre></li><li><p>删除<code>node_modules</code>文件中的<code>hexo-prism-plugin</code>文件夹</p></li></ol><h3 id="2-禁用highlight"><a href="#2-禁用highlight" class="headerlink" title="2.  禁用highlight"></a>2.  禁用highlight</h3><p>打开根目录下的<code>_config.yml</code>文件，修改配置</p><pre><code class="line-numbers language-yml">highlight:  enable: false  line_number: false  auto_detect: false  tab_replace: &#39;&#39;  wrap: false  hljs: false</code></pre><h3 id="3-获取prism"><a href="#3-获取prism" class="headerlink" title="3.  获取prism"></a>3.  获取prism</h3><p>下载页面：<a href="https://links.jianshu.com/go?to=https://prismjs.com/download.html">https://prismjs.com/download.html</a>；选择 theme 主题、language 支持的语言（不要选太多，够用就好）、plugin 插件（我选的是Line Numbers、Highlight Keywords，其他的看自己需求）；然后点击下载按钮就行了；下载到本地。将他们移动到对应的的位置，它们的路径分别是：</p><pre><code class="line-numbers language-txt">项目根目录\themes\hexo-theme-matery\source\css\prism.css项目根目录\themes\hexo-theme-matery\source\js\prism.js</code></pre><h3 id="4-配置-prism"><a href="#4-配置-prism" class="headerlink" title="4.  配置 prism"></a>4.  配置 prism</h3><ol><li><p>修改<code>\themes\hexo-theme-matery\layout\_partial\footer.ejs</code>， 在尾部添加以下代码：</p><pre><code class="line-numbers language-ejs">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/prism.css&quot;&gt;</code></pre></li><li><p>修改 <code>\themes\hexo-theme-matery\layout\_partial\footer.ejs</code>，在尾部添加以下代码</p><pre><code class="line-numbers language-ejs">&lt;script src=&quot;/js/prism.js&quot; async&gt;&lt;/script&gt;    </code></pre></li></ol><h3 id="5-修改博客配置"><a href="#5-修改博客配置" class="headerlink" title="5. 修改博客配置"></a>5. 修改博客配置</h3><p>打开根目录下的<code>_config.yml</code>文件，添加下面代码</p><pre><code class="line-numbers language-yml">marked:  langPrefix: line-numbers language-</code></pre><h3 id="6-测试prism"><a href="#6-测试prism" class="headerlink" title="6.  测试prism"></a>6.  测试prism</h3><pre><code class="line-numbers language-git">hexo cleanhexo ghexo s</code></pre><p>大功告成！！！</p><p>这个问题解决了，烦心的事情又少了一件，终于可以快快乐乐的写博客了！</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>126.单词接龙 II-困难</title>
      <link href="2021/03/14/126-dan-ci-jie-long-ii-kun-nan/"/>
      <url>2021/03/14/126-dan-ci-jie-long-ii-kun-nan/</url>
      
        <content type="html"><![CDATA[<h3 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个起始字符串和一个终止字符串，以及一个单词表，求是否可以将起始字符串每次改一个字符，直到改成终止字符串，且所有中间的修改过程表示的字符串都可以在单词表里找到。</p><p>若存在，输出需要修改次数最少的所有更改方式。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入是两个字符串，输出是一个二维字符串数组，表示每种字符串修改方式。</p><pre><code class="line-numbers language-C++">Input:beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们可以把起始字符串、终止字符串、以及单词表里所有的字符串想象成节点。若两个字符串只有一个字符不同，那么它们相连。因为题目需要输出修改次数最少的所有修改方式，因此我们可以使用广度优先搜索，求得起始节点到终止节点的最短距离。</p><p>我们同时还使用了一个小技巧：我们并不是直接从起始节点进行广度优先搜索，直到找到终止节点为止；而是从起始节点和终止节点分别进行广度优先搜索，每次只延展当前层节点数最少的那一端，这样我们可以减少搜索的总结点数。举例来说，假设最短距离为 4，如果我们只从一端搜索 4 层，总遍历节点数最多是 1 + 2 + 4 + 8 + 16 = 31；而如果我们从两端各搜索两层，总遍历节点数最多只有 2 × (1 + 2 + 4) = 14。</p><p>在搜索结束后，我们还需要通过回溯法来重建所有可能的路径。</p><pre><code class="line-numbers language-C++">class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;        //ans用来存放最后的输出结果        vector&lt;vector&lt;string&gt;&gt; ans;        //dict用来以set的形式存放字典wordList        unordered_set&lt;string&gt; dict;        for (const auto&amp; w: wordList) &#123;            dict.insert(w);        &#125;        //如果字典里没有endList，直接返回结果        if (!dict.count(endWord)) &#123;            return ans;        &#125;        //删除字典里的beginWord和endWord        dict.erase(beginWord);        dict.erase(endWord);        unordered_set&lt;string&gt; q1&#123;beginWord&#125;, q2&#123;endWord&#125;;        unordered_map&lt;string, vector&lt;string&gt;&gt; next;        bool reversed = false, found = false;        while (!q1.empty()) &#123;                unordered_set &lt;string&gt; q;                for (const auto&amp; w: q1) &#123;                    string s = w;                    for (size_t i = 0; i &lt; s.size(); i++) &#123;                        char ch = s[i];                         for (int j = 0; j &lt; 26; j++) &#123;                            s[i] = j + &#39;a&#39;;                            if (q2.count(s)) &#123;                                reversed ? next[s].push_back(w) : next[w].push_back(s);                                 found = true;                            &#125;                            if (dict.count(s)) &#123;                                reversed ? next[s].push_back(w) : next[w].push_back(s);                                q.insert(s);                            &#125;                        &#125;                        s[i] = ch;                    &#125;                &#125;                if (found) &#123;                     break;                &#125;                for (const auto&amp; w: q) &#123;                    dict.erase(w);                &#125;                if (q.size() &lt;= q2.size()) &#123;                    q1 = q;                &#125; else &#123;                     reversed = !reversed;                    q1 = q2;                    q2 = q;                &#125;        &#125;        if (found) &#123;            vector&lt;string&gt; path = &#123;beginWord&#125;;            backtracking(beginWord, endWord, next, path, ans);        &#125;        return ans;    &#125;    void backtracking(const string&amp; src, const string&amp; dst, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; next, vector&lt;string&gt;&amp; path,vector&lt;vector&lt;string&gt;&gt;&amp; ans) &#123;        if (src == dst) &#123;            ans.push_back(path);            return;        &#125;        for (const auto&amp; s : next[src]) &#123;            path.push_back(s);            backtracking(s, dst, next, path, ans);            path.pop_back();        &#125;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的学习使用记录</title>
      <link href="2021/03/14/docker-de-xue-xi-shi-yong-ji-lu/"/>
      <url>2021/03/14/docker-de-xue-xi-shi-yong-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="容器数据卷使用"><a href="#容器数据卷使用" class="headerlink" title="容器数据卷使用"></a>容器数据卷使用</h2><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><pre><code class="line-numbers language-Shell">#1.启动容器mysqldocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=密码 --name mysql mysql:8.0.23#命令-d 后台运行-p 端口映射-v 卷挂载-e 环境配置-- name 容器名字#2.查看容器的信息 docker inspect 容器id </code></pre><p><img src="/2021/03/14/docker-de-xue-xi-shi-yong-ji-lu/image-20210314200223048.png" alt="image-20210314200223048"></p><pre><code class="line-numbers language-shell">-v /home/mysql/conf:/etc/mysql/conf.d     #&#39;:&#39;前面是主机内地址， &#39;:&#39;后面是docker容器内地址</code></pre><h3 id="三种挂载方式"><a href="#三种挂载方式" class="headerlink" title="三种挂载方式"></a>三种挂载方式</h3><pre><code class="line-numbers language-shell"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载-v 容器内路径            #匿名挂载-v 卷名：容器内路径          #具名挂载-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</code></pre><p>拓展</p><pre><code class="line-numbers language-shell"># 通过 -v 容器内路径： ro rw 改变读写权限ro #readonly 只读rw #readwrite 可读可写$ docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx$ docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk 评论登录 403 问题解决</title>
      <link href="2021/02/19/gitalk-ping-lun-deng-lu-403-wen-ti-jie-jue/"/>
      <url>2021/02/19/gitalk-ping-lun-deng-lu-403-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cuiqingcai.com/30010.html">https://cuiqingcai.com/30010.html</a></p><p>博主解决问题的思路很清晰，值得学习!</p><p><a href="https://imgchr.com/i/yfzGSe"><img src="https://s3.ax1x.com/2021/02/19/yfzGSe.jpg" alt="yfzGSe.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牧羊少年的奇幻之旅</title>
      <link href="2021/02/18/mu-yang-shao-nian-qi-huan-zhi-lu/"/>
      <url>2021/02/18/mu-yang-shao-nian-qi-huan-zhi-lu/</url>
      
        <content type="html"><![CDATA[<p>​        </p><p><img src="/2021/02/18/mu-yang-shao-nian-qi-huan-zhi-lu/%E7%89%A7%E7%BE%8A%E5%B0%91%E5%B9%B4%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85%E5%B0%81%E7%9A%AE.jpg" alt="牧羊少年奇幻之旅封皮">    </p><p>​        我是一个牧羊人，重复做着同一个梦。梦里告诉我有宝藏。在撒冷之王的指引下，我踏上了寻宝之旅。</p><p>​        第一天，我的钱就全部被我信任的人骗去。我决定不再相信任何人，我疲惫至极，当我将要放弃的时候，撒冷之王的话语回荡在我的耳边：当你想要得到某种东西的时候，整个宇宙都会合力助你实现愿望。我已不再悲伤，我怀着一个念头沉重睡去——我是一个寻宝人，明天我将开始新的旅途。</p><p>​        我遇见了水晶店的主人，我助他的水晶店焕然一新，他付我报酬使我得以继续寻宝，“命中注定”，水晶店的主人送我离开时这样说。</p><p>​        我又遇见了一个英国人，我本不想与他打交道，“一切都有预兆”，他从口中吐出这几个字，我改变了想法，我决定和他一起开始这趟沙漠之旅，因为撒冷之王说过同样的话。这位英国人和我一样有使命，他一生的一半光阴都花在了炼金术上，他要去寻找一位炼金术士。</p><p>​        沙漠之旅并不容易，一路的艰苦跋涉终使我们到达了绿洲，我为绿洲带来了战争的预兆，他们将封我为顾问，我已厌倦了这趟旅途，至高的待遇诱使我留在这里。开玩笑般的我再次遇见了一个人，他使我明白，当我老之将至，站在梧桐树下回首自己度过的虚无的一生，遥想被深埋在地下的宝藏时已为时晚矣。</p><p>​        他正是炼金术士。</p><p>​        我再次开启这趟征途，种种经历让我开始尝试倾听内心的声音，我弄懂了心所耍的各种手段和花招。被逼无奈之下我开始领悟世界的语言，感悟到了爱的力量，觉悟到了这一切皆由我的双手写就。我抵达了金字塔，奋力挖掘，然而一无所获。</p><p>​        一个经过的难民在知道我挖掘的原因之后开始耻笑我说：“你真愚蠢，我也和你一样做过同样的梦，我梦到与此地有一个沙漠之隔的教堂，一个牧羊人经常在那里过夜，如果我在那里挖掘，我会找到宝藏，可我不会像你这么蠢。”</p><p>​        我感谢这个不相信梦的家伙，我找到我的宝藏了。我站起来拍拍身上的沙子，金字塔正朝我笑呢。</p><p>​        我回到了教堂，在无果树下挖掘。“老巫师”我自言自语，“你什么都知道，甚至还为我留了回来的钱，看到我衣衫褴褛的跑回来，他们都笑了，你就不能让我免遭这一切？”</p><p>​        “不能，”我听到有个声音说，“如果我告诉你这一切，那你就看不到金字塔了，它很壮美，不是吗？”</p><p>​        那分明是炼金术士的声音。<br>​                                                                    ——《牧羊少年的奇幻之旅》</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
