<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>QZ</title>
      <link href="2021/08/09/qiu-zhao/"/>
      <url>2021/08/09/qiu-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的CountDownLatch和CyclicBarrier的理解和区别"><a href="#Java的CountDownLatch和CyclicBarrier的理解和区别" class="headerlink" title="Java的CountDownLatch和CyclicBarrier的理解和区别"></a>Java的CountDownLatch和CyclicBarrier的理解和区别</h2><p>从字面上理解，CountDown表示减法计数，Latch表示门闩的意思，计数为0的时候就可以打开门闩了。Cyclic Barrier表示循环的障碍物。两个类都含有这一个意思：对应的线程都完成工作之后再进行下一步动作，也就是大家都准备好之后再进行下一步。然而两者最大的区别是，进行下一步动作的动作实施者是不一样的。这里的“动作实施者”有两种，一种是主线程（即执行main函数），另一种是执行任务的其他线程，后面叫这种线程为“其他线程”，区分于主线程。对于CountDownLatch，当计数为0的时候，下一步的动作实施者是<strong>main函数</strong>；对于CyclicBarrier，下一步动作实施者是<strong>“其他线程”</strong>。</p><h2 id="大顶堆和小顶堆"><a href="#大顶堆和小顶堆" class="headerlink" title="大顶堆和小顶堆"></a>大顶堆和小顶堆</h2><pre><code>// 小顶堆PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();// 大顶堆PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</code></pre><h2 id="Seckill"><a href="#Seckill" class="headerlink" title="Seckill"></a>Seckill</h2><p>运行jar包</p><p><code>nohup java -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -jar seckill-0.0.1-SNAPSHOT.jar --spring.profiles.active=test &amp;</code></p><p>启动nginx</p><p><code>nginx -c /etc/nginx/nginx.conf</code></p><p><img src="/2021/08/09/qiu-zhao/image-20210723191857491.png" alt="image-20210723191857491"></p><h2 id="华为云服务器"><a href="#华为云服务器" class="headerlink" title="华为云服务器"></a>华为云服务器</h2><p> <strong>4核8G + 10M带宽</strong></p><h2 id="linux清除缓存：需要root权限"><a href="#linux清除缓存：需要root权限" class="headerlink" title="linux清除缓存：需要root权限"></a>linux清除缓存：需要root权限</h2><p>$ sync<br>$ echo 3 &gt;/proc/sys/vm/drop_caches</p><p>上面的echo 3 是清理所有缓存</p><p>echo 0 是不释放缓存</p><p>echo 1 是释放页缓存</p><p>ehco 2 是释放dentries和inodes缓存</p><p>echo 3 是释放 1 和 2 中说道的的所有缓存</p><h2 id="spring-拦截器和过滤器的区别"><a href="#spring-拦截器和过滤器的区别" class="headerlink" title="spring 拦截器和过滤器的区别"></a>spring 拦截器和过滤器的区别</h2><p>过滤器 和 拦截器 均体现了AOP的编程思想，都可以实现诸如日志记录、登录鉴权等功能，但二者的不同点也是比较多的。</p><p>过滤器：</p><p>是在javaweb中，你传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符.。</p><p>拦截器 ：</p><p>是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。</p><p><strong>触发时机不同</strong></p><p><img src="/2021/08/09/qiu-zhao/image-20210726093158281.png" alt="image-20210726093158281"></p><p>工作流程及顺序</p><p><img src="/2021/08/09/qiu-zhao/image-20210726092721524.png" alt="image-20210726092721524"></p><h2 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h2><p>首先，Spring Boot项目创建完成会默认生成一个名为 <code>*Application</code> 的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。</p><p>SpringApplication调用的run方法的大致流程，如下图：</p><p><img src="/2021/08/09/qiu-zhao/image-20210808154151717.png" alt="image-20210808154151717"></p><p>其中，SpringApplication在run方法中重点做了以下操作：</p><ul><li><p>获取监听器和参数配置；</p></li><li><p>打印Banner信息；</p></li><li><p>创建并初始化容器；</p></li><li><p>监听器发送通知。</p></li></ul><h2 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h2><p>使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。Spring Boot实现该运作机制锁涉及的核心部分如下图所示：</p><p><img src="/2021/08/09/qiu-zhao/image-20210808154241427.png" alt="image-20210808154241427"></p><p>整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p><h2 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h2><table><thead><tr><th><strong>传播行为</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td>REQUIRED</td><td>表示<code>当前方法必须运行在事务中</code>。如果当前事务存在，方法将会在该事务中运行。否则会启动一个新的事务。<strong>只要内层方法报错抛出异常，即使外层有try-catch，该事务也会回滚！外层事务提交了，内层才会提交。内外只要有报错，他俩会一起回滚。</strong></td></tr><tr><td>SUPPORTS</td><td>表示<code>当前方法不需要事务上下文</code>，但是如果存在当前事务的话，那么该方法会在这个事务中运行。没有就算了。</td></tr><tr><td>MANDATORY</td><td>表示<code>该方法必须在事务中运行</code>，如果当前事务不存在，则会抛出一个异常。</td></tr><tr><td>REQUIRED_NEW</td><td>表示<code>当前方法必须运行在它自己的事务中</code>。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。<strong>当前方法自己提交，内层报错回滚，外层try-catch内层的异常，外层不会回滚。内层事务结束，内层就提交了，不用等着外层一起提交。外层报错回滚，不影响内层。</strong></td></tr><tr><td>NOT_SUPPORTED</td><td>表示<code>该方法不应该运行在事务中</code>。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td></tr><tr><td>NEVER</td><td>表示<code>当前方法不应该运行在事务上下文中</code>。如果当前正有一个事务在运行，则会抛出异常</td></tr><tr><td>NESTED</td><td>表示如果当前已经存在一个事务，那么该方法将会在<code>嵌套事务</code>中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与propagation.REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务。<strong>外层事务提交了，内层才会提交。外层回滚，内层也回滚。如果只是内层回滚，不影响外层。</strong></td></tr></tbody></table><h2 id="Bean-的加载过程是怎样的？"><a href="#Bean-的加载过程是怎样的？" class="headerlink" title="Bean 的加载过程是怎样的？"></a>Bean 的加载过程是怎样的？</h2><ol><li><code>获取 BeanName</code>，对传入的 name 进行解析，转化为可以从 Map 中获取到 BeanDefinition 的 bean name。</li><li><code>合并 Bean 定义</code>，对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。</li><li><code>实例化</code>，使用构造或者工厂方法创建 Bean 实例。</li><li><code>属性填充</code>，寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。</li><li><code>初始化</code>，调用自定义的初始化方法。</li><li><code>获取最终的 Bean</code>，如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。</li></ol><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol><li><p>Bean容器找到配置文件中Spring Bean的定义。</p></li><li><p>Bean容器利用Java Reflection API创建一个Bean的实例。</p></li><li><p>如果涉及到一些属性值，利用set()方法设置一些属性值。</p></li><li><p>如果Bean实现了BeanNameAware接口，调用<code>setBeanName()</code>方法，传入Bean的名字。</p><p><img src="/2021/08/09/qiu-zhao/image-20210808163532769.png" alt="image-20210808163532769"></p></li><li><p>如果Bean实现了BeanClassLoaderAware接口，调用<code>setBeanClassLoader()</code>方法，传入ClassLoader对象的实例。</p></li><li><p>如果Bean实现了BeanFactoryAware接口，调用<code>setBeanClassFacotory()</code>方法，传入ClassLoader对象的实例。</p></li><li><p>与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。</p></li><li><p>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行<code>postProcessBeforeInitialization()</code>方法。</p></li><li><p>如果Bean实现了InitializingBean接口，执行<code>afeterPropertiesSet()</code>方法。</p></li><li><p>如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。</p></li><li><p>如果有和加载这个Bean的Spring容器相关的BeanPostProcess对象，执行postProcessAfterInitialization()方法。</p></li><li><p>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行<code>destroy()</code>方法。</p></li><li><p>当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。</p></li></ol><h2 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h2><p>采用死锁检测算法即银行家算法</p><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p><img src="/2021/08/09/qiu-zhao/qq_pic_merged_1628406185407.jpg.jpg" alt="qq_pic_merged_1628406185407.jpg"></p><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p><img src="/2021/08/09/qiu-zhao/D1F5825E9F11AE98D42D7EEB8BEAD8CC-1628406321135.jpg" alt="img"></p><h2 id="Redis和MySQL数据一致性问题怎么解决"><a href="#Redis和MySQL数据一致性问题怎么解决" class="headerlink" title="Redis和MySQL数据一致性问题怎么解决"></a>Redis和MySQL数据一致性问题怎么解决</h2><p><a href="https://mp.weixin.qq.com/s/0LtKJGcAoLO_EGrd0fkXhw">美团二面：Redis与MySQL双写一致性如何保证？</a></p><h2 id="消费者和生产者模型"><a href="#消费者和生产者模型" class="headerlink" title="消费者和生产者模型"></a>消费者和生产者模型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p><strong>生产者消费者模式</strong>就是<strong>通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯</strong>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是<strong>用来给生产者和消费者解耦的</strong>。</p><h3 id="基于BlockingQueue的生产者消费者模型"><a href="#基于BlockingQueue的生产者消费者模型" class="headerlink" title="基于BlockingQueue的生产者消费者模型"></a><strong>基于BlockingQueue的生产者消费者模型</strong></h3><p>BlockingQueue 在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，<strong>当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞</strong>，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)</p><p><a href="https://www.jianshu.com/p/66e8b5ab27f6">Java生产者和消费者模型的5种实现方式</a></p><h2 id="项目里哪里用到了线程池"><a href="#项目里哪里用到了线程池" class="headerlink" title="项目里哪里用到了线程池"></a>项目里哪里用到了线程池</h2><p>自定义线程池异步查询</p><pre><code class="line-numbers language-java">* 如果远程查询比较慢，比如方法当中有好几个远程查询，都要好几秒以上，等整个方法返回可能就要很久，这块你是怎么处理的？* 那么为了能提升远程查询的效率，可以使用线程池的方式* 要做的操作就是将所有的线程全部放到自己手写的线程池里面* 所以每一个服务都要配置一个自己的线程池* 完全使用线程池来控制住所有的请求</code></pre><h2 id="项目里哪里用到了什么设计模式"><a href="#项目里哪里用到了什么设计模式" class="headerlink" title="项目里哪里用到了什么设计模式"></a>项目里哪里用到了什么设计模式</h2><h2 id="Spring是怎么解决循环依赖的？"><a href="#Spring是怎么解决循环依赖的？" class="headerlink" title="Spring是怎么解决循环依赖的？"></a>Spring是怎么解决循环依赖的？</h2><h3 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a><strong>什么是循环依赖？</strong></h3><p>举个例子，这里有三个类 A、B、C，然后 A 关联 B，B 关联 C，C 又关联 A，这就形成了一个循环依赖。<code>如果是方法调用是不算循环依赖的，循环依赖必须要持有引用</code>。</p><p><img src="/2021/08/09/qiu-zhao/image-20210808164013982.png" alt="image-20210808164013982"></p><p>循环依赖发生的场景：</p><ul><li><p><code>构造器循环依赖</code>：依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。</p></li><li><p><code>设值循环依赖</code>：依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。</p><p><code>如果是构造器循环依赖</code>，本质上是无法解决的。比如我们准调用 A 的构造器，发现依赖 B，于是去调用 B 的构造器进行实例化，发</p></li></ul><p>又依赖 C，于是调用 C 的构造器去初始化，结果依赖 A，整个形成一个死结，导致 A 无法创建。</p><p>  <code>如果是设值循环依赖</code>，Spring 框架只支持单例下的设值循环依赖。Spring 通过对还在创建过程中的单例，缓存并提前暴露该单例，使得其他实例可以引用该依赖。</p><h3 id="循环依赖得解决思路是什么样的？"><a href="#循环依赖得解决思路是什么样的？" class="headerlink" title="循环依赖得解决思路是什么样的？"></a><strong>循环依赖得解决思路是什么样的？</strong></h3><p> Spring解决循环依赖，主要的思路就是依据三级缓存（<code>解链</code>）。</p><p>  在实例化A时调用doGetBean，发现A依赖的B的实例，此时调用doGetBean去实例B，实例化的B的时候发现又依赖A，如果不解决这个循环依赖的话此时的doGetBean将会无限循环下去，导致内存溢出，程序奔溃。</p><p>  如果Spring引用一个早期对象，并且把这个”早期引用”并将其注入到容器中，让B先完成实例化，此时A就获取B的引用，完成实例化。</p><blockquote><p>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。<br>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean<br>三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂。</p></blockquote><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a><strong>CAP理论</strong></h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中</p><ul><li>一致性（consistency）<br>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性（Availability）<br>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容惜性（Partitiontolerance）<ul><li>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区(partition)。<br>分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</li></ul></li></ul><p>CAP原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾</p><ul><li>CP要求一致性（有一个没同步好就不可用）</li><li>AP要求高可用</li></ul><h3 id="选举与同步理论"><a href="#选举与同步理论" class="headerlink" title="选举与同步理论"></a><strong>选举与同步理论</strong></h3><p><a href="http://thesecretlivesofdata.com/raft/">分布式一致性动画演示</a></p><p>raft是一个实现分布式一致性的协议</p><p>结点的状态：</p><ul><li><p>follower</p></li><li><p>candidate</p></li><li><p>leader</p><p>选举leader：</p></li><li><p>默认都以follower状态启动，follower监听不到leader，就称为一个candidate</p></li><li><p>投票给自己，然后告诉其他人，同时也收到别人的投票信息。根据投票信息和投票信息里带的信息（如那个节点里的数据）</p></li><li><p>收到投票后，改选一个自己觉得最靠谱的。某一节点收到票数超过一半就变成leader</p><blockquote><p>raft有两个超时时间控制领导选举：</p><ul><li>选举超时：从follower到candidate的时间，150ms-300ms（自旋时间），这个时间段内没收到leader的心跳就变为候选者。 </li><li>自旋时间结束后变成candidate，开始一轮新的选举（老师上课举的例子是）</li><li>投出去票后重新计时自旋</li><li>leader就发送追加日志给follower，follower就正常</li><li>消息发送的，心跳时间：如10ms，leader收到投票后，下一次心跳时就带上消息，follower收到消息后重置选举时间</li><li>leader宕机，follower收不到心跳，开始新的选举</li></ul></blockquote></li></ul><p>写数据：</p><ul><li><p>接下来所有的数据都要先给leader，leader派发给follower</p></li><li><p>比如领导收到信息5后，领导先在leader的log中写入变化set 5。（上面的动态红颜色代表没提交），此时5还没提交，而是改了</p><p>leader的log后，</p></li><li><p>leader下一次心跳时，顺便带着信息让follower也去改变follower的log，follower写入日志成功后，发送确认ack 5给leader，</p></li><li><p>leader收到大多数的ack后，leader就自己正式写入数据，然后告诉follower提交写入硬盘/内存吧（这个过程和响应客户端是同时的）。这个过程叫做日志复制（也有过半机制）</p></li><li><p>然后leader响应说集群写入好了</p></li></ul><p>如果有的结点消息滞后了：</p><p>5台机器因为局域网隔离又分为3、2生成两个leader怎么办：</p><p>对于1,2结点那个leader，更新log后收不到大多数的ack（得超过1个ack），所以改log不成功，一直保存不成功</p><p>对于345结点的leader：收到消息后更新log并且收到ack过半且超过1个，成功保存。</p><p>此时网络又通了，以更高轮选举的leader为主，退位一个leader。那1，2结点日志都回滚，同步新leader的log。这样就都一致性了</p><p>另外注意：集群一般都是单数，因为有过半机制。比如原来集群6个机器，分为2半后，各3个，选leader时谁都拿不到6/2+1=4个投票，所以都没有leader</p><p>更多动画（可以自己选择宕机情况）raft.github.io</p><p>但一般都是保证AP，舍弃C</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a><strong>BASE理论</strong></h3><p>后续发现扣减不一致后，再恢复</p><p>BASE理论是对CAP理论的延伸，思想是即使无法做到强一致性（CAP的一致性就是强一致性），但可以采用弱一致性，即最终一致性</p><p>BASE是指：</p><ul><li>基本可用(BasicallyAvailable)<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。<ul><li>响应时间上的损失：正常情况下搜索引擎需要在0．5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1～2秒。</li><li>功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li>软状态（soft state）<ul><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</li></ul></li><li>最终一致性（Eventual Consistency）<ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。（这也是分布式事务的想法）</li></ul></li></ul><p>从客户端角度，多进程并发访同时，更新过的数据在不同程如何获的不同策珞，决定了不同的一致性。</p><ul><li>对于关系型要求更新过据能后续的访同都能看到，这是强一致性。</li><li>如果能容忍后经部分过者全部访问不到，则是弱一致性</li><li>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性</li></ul><h3 id="分布式事务几种方案"><a href="#分布式事务几种方案" class="headerlink" title="分布式事务几种方案"></a><strong>分布式事务几种方案</strong></h3><h4 id="1-2PC模式-XA事务"><a href="#1-2PC模式-XA事务" class="headerlink" title="1) 2PC模式(XA事务)"></a><strong>1) 2PC模式(XA事务)</strong></h4><p>数据库支持的2pc【2二阶段提交】，又叫做XA Transactions</p><p>支持情况：mysql从5．5版本开始支持，SQLserver2005开始支持，Oracle7开始支持。</p><p>其中，XA是一个两阶段提交协议，该协议分为以下两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交（P090此操作，并反映是否可以提交，</li><li>第二阶段：事务协调器要求每个数据库提交数据。</li><li>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息</li></ul><p><img src="/2021/08/09/qiu-zhao/20210315014838.png" alt="img"></p><p>如图所示，如果有订单服务和库存服务要求分布式事务，要求有一个总的事务管理器</p><p>总的事务管理让事务分为两个阶段，</p><ul><li>第一个阶段是预备（log）。</li><li>第二个阶段是正式提交（commit）<br>总事务管理器接收到两个服务都预备好了log（收到ack），就告诉他们commit</li></ul><p>如果有一个没准备好，就回滚所有人。</p><p>总结2PC：</p><ul><li>XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。</li><li>性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景</li><li>XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录阶段日志，主备切换回导致主库与备库数据不一致。</li><li>许多nosql没有支持XA，这让XA的应用场景变得非常狭隘。</li><li>也有3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</li></ul><h4 id="2-柔性事务-TCC事务补偿型方案"><a href="#2-柔性事务-TCC事务补偿型方案" class="headerlink" title="2) 柔性事务-TCC事务补偿型方案"></a><strong>2) 柔性事务-TCC事务补偿型方案</strong></h4><ul><li>刚性事务：遵循ACID原则，强一致性。</li><li>柔性事务：遵循BASE理论，最终一致性；</li></ul><p>与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p><ul><li>一阶段prepare行为：调用自定义的prepare逻辑。</li><li>二阶段commit行为：调用自定义的commit逻憬。</li><li>二阶段rollback行为：调用自定义的rollback逻辑。</li></ul><p>所TCC模式，是指支持 自定义的 分支事务纳入到全局事务的管理中。</p><p><img src="/2021/08/09/qiu-zhao/10708517-79ae61c85f1bdddc.png" alt="img"></p><h4 id="3）柔性事务-最大努力通知型方案"><a href="#3）柔性事务-最大努力通知型方案" class="headerlink" title="3）柔性事务-最大努力通知型方案"></a><strong>3）柔性事务-最大努力通知型方案</strong></h4><p>按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接囗进行核对。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送就请求，设置最大通知次数。达到通知次数后即不再通知。</p><p>案例：银行涌知、商户通知等（各大交易业务平台间的商户涌知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调</p><blockquote><p>大业务调用单，库存，积分。最后积分失败，则一遍遍通知他们回滚</p><p>让子业务监听消息队列</p><p>如果收不到就重新发</p></blockquote><p><strong>4）柔性事务=可靠消息+最终一致性方案（异步确保型）</strong><br>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送捎息，实时捎息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><h2 id="MQ的一些问题"><a href="#MQ的一些问题" class="headerlink" title="MQ的一些问题"></a>MQ的一些问题</h2><h3 id="8-1-消息丢失问题"><a href="#8-1-消息丢失问题" class="headerlink" title="8.1 消息丢失问题"></a>8.1 消息丢失问题</h3><p>秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。</p><p>那么，如何防止消息丢失呢？</p><p>答：加一张消息发送表。</p><p><img src="/2021/08/09/qiu-zhao/1.png" alt="img">在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。</p><p>如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。</p><p>这时候，要如何处理呢？</p><p>答：使用job，增加重试机制。</p><p><img src="/2021/08/09/qiu-zhao/2.png" alt="图片">用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。</p><h3 id="8-2-重复消费问题"><a href="#8-2-重复消费问题" class="headerlink" title="8.2 重复消费问题"></a>8.2 重复消费问题</h3><p>本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。</p><p>那么，如何解决重复消息问题呢？</p><p>答：加一张消息处理表。<img src="/2021/08/09/qiu-zhao/3.png" alt="图片"></p><p>消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。</p><p>有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。</p><h3 id="8-3-垃圾消息问题"><a href="#8-3-垃圾消息问题" class="headerlink" title="8.3 垃圾消息问题"></a>8.3 垃圾消息问题</h3><p>这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。</p><p>那么，如何解决这个问题呢？<img src="/2021/08/09/qiu-zhao/4.png" alt="图片">每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。</p><p>这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。</p><h3 id="8-4-延迟消费问题"><a href="#8-4-延迟消费问题" class="headerlink" title="8.4 延迟消费问题"></a>8.4 延迟消费问题</h3><p>通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。</p><p>那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？</p><p>我们首先想到的可能是job，因为它比较简单。</p><p>但job有个问题，需要每隔一段时间处理一次，实时性不太好。</p><p>还有更好的方案？</p><p>答：使用延迟队列。</p><p>我们都知道rocketmq，自带了延迟队列的功能。</p><p><img src="/2021/08/09/qiu-zhao/5.png" alt="图片">下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。</p><p>还有个关键点，用户完成支付之后，会修改订单状态为已支付。</p><p><img src="/2021/08/09/qiu-zhao/6.png" alt="图片"></p><p><strong>尚硅谷</strong></p><p><img src="/2021/08/09/qiu-zhao/image-20210810143355988.png" alt="image-20210810143355988"></p><p><img src="/2021/08/09/qiu-zhao/image-20210810142909988.png" alt="image-20210810142909988"></p><p><img src="/2021/08/09/qiu-zhao/image-20210810144558527.png" alt="image-20210810144558527"></p><p><img src="/2021/08/09/qiu-zhao/image-20210810145103937.png" alt="image-20210810145103937"></p><h2 id="UDP如何实现可靠传输？"><a href="#UDP如何实现可靠传输？" class="headerlink" title="UDP如何实现可靠传输？"></a>UDP如何实现可靠传输？</h2><p><strong>确认机制</strong></p><p>UDP要想可靠，就要接收方收到UDP之后回复个确认包。</p><p><strong>超时重传</strong></p><p>发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求。</p><p><strong>滑动窗口</strong></p><p>当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令学习</title>
      <link href="2021/05/24/git-ming-ling-xue-xi/"/>
      <url>2021/05/24/git-ming-ling-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="欢迎光临-Learn-Git-Branching"><a href="#欢迎光临-Learn-Git-Branching" class="headerlink" title="欢迎光临 Learn Git Branching"></a>欢迎光临 Learn Git Branching</h2><p>你对 Git 感兴趣吗？那么算是来对地方了！ “Learning Git Branching” 可以说是目前为止最好的教程了，在沙盒里你能执行相应的命令，还能看到每个命令的执行情况； 通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能，在这个过程中你可能还会发现一些有意思的事情。</p><p>关闭这个对话框以后，你会看到我们提供的许多关卡。如果你是初学者，从第一关开始逐个向后挑战就是了。 而如果你已经入门了，可以略过前面，直接挑战后面更有难度的关卡。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>如果你还没看过演示，请<a href="https://oschina.gitee.io/learn-git-branching/?demo">到此</a>查看。</p><p>PS：想直接进入沙盒？ 在 URL 后头加上 <code>?NODEMO</code> 就可以了，试一下<a href="https://oschina.gitee.io/learn-git-branching/?NODEMO">这个链接</a>：</p><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="循序渐进地介绍-Git-主要命令"><a href="#循序渐进地介绍-Git-主要命令" class="headerlink" title="循序渐进地介绍 Git 主要命令"></a>循序渐进地介绍 Git 主要命令</h4><p><em>1: Git Commit</em></p><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p><p>关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！</p><p>咱们来实际操作一下，看看提交记录是怎样的。右边展示了一个（小型）Git 代码库。当前有两个提交记录 —— 初始提交 <code>C0</code> 和其后可能包含某些有用修改的提交 <code>C1</code>。</p><p>点击下面的按钮创建一个新的提交记录。</p><p><img src="/2021/05/24/git-ming-ling-xue-xi/image-20210524204447482.png" alt="image-20210524204447482"></p><p><strong>git commit</strong></p><p><img src="/2021/05/24/git-ming-ling-xue-xi/image-20210524204501888.png" alt="image-20210524204501888"></p><p>好了！非常棒！我们刚才修改了代码库，并把这些修改保存成了一个提交记录 <code>C2</code>。<code>C2</code> 的父节点是 <code>C1</code>，父节点是当前提交中变更的基础。</p><p><em>2: Git Branch</em></p><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p><pre><code>早建分支！多用分支！</code></pre><p>这是因为即使创建再多分的支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p><p>咱们通过实际操作来看看分支是什么样子的。</p><p>接下来，我们将要创建一个到名为 <code>newImage</code> 的分支。</p><p><img src="/2021/05/24/git-ming-ling-xue-xi/image-20210524204943421.png" alt="image-20210524204943421"></p><p><strong>git branch newImage</strong></p><p><img src="/2021/05/24/git-ming-ling-xue-xi/image-20210524205031058.png" alt="image-20210524205031058"></p><p>看到了吗，创建分支就是这么容易！新创建的分支 <code>newImage</code> 指向的是提交记录 <code>C1</code>。</p><p>==前面的基础篇简单，记录一些重点吧。==</p><p>创建新分支并切换分支</p><p>git checkout -b bugFix 等价于 git branch bugFix + git checkout bugFix </p><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p><p>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS初见</title>
      <link href="2021/05/03/aqs-chu-jian/"/>
      <url>2021/05/03/aqs-chu-jian/</url>
      
        <content type="html"><![CDATA[<p>本篇文章共转载了两篇有关AQS的文章，认真看完的话对理解AQS有十分大的帮助。</p><p>文章原址：</p><p><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">https://javadoop.com/post/AbstractQueuedSynchronizer</a></p><p><a href="http://www.imooc.com/article/293135">http://www.imooc.com/article/293135</a></p><h2 id="篇一、一行一行源码分析清楚AbstractQueuedSynchronizer"><a href="#篇一、一行一行源码分析清楚AbstractQueuedSynchronizer" class="headerlink" title="篇一、一行一行源码分析清楚AbstractQueuedSynchronizer"></a>篇一、一行一行源码分析清楚AbstractQueuedSynchronizer</h2><p>创建时间: 2017-06-16 00:00:00</p><p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><p>申明以下几点：</p><ol><li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li><li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li><li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li></ol><h3 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h3><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><pre><code class="line-numbers language-java">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的private transient volatile Node head;// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表private transient volatile Node tail;// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1private volatile int state;// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</code></pre><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><p><img src="/2021/05/03/aqs-chu-jian/aqs-0.png" alt="aqs-0"></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p><pre><code class="line-numbers language-java">static final class Node &#123;    // 标识节点当前在共享模式下    static final Node SHARED = new Node();    // 标识节点当前在独占模式下    static final Node EXCLUSIVE = null;    // ======== 下面的几个int常量是给waitStatus用的 ===========    /** waitStatus value to indicate thread has cancelled */    // 代码此线程取消了争抢这个锁    static final int CANCELLED =  1;    /** waitStatus value to indicate successor&#39;s thread needs unparking */    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒    static final int SIGNAL    = -1;    /** waitStatus value to indicate thread is waiting on condition */    // 本文不分析condition，所以略过吧，下一篇文章会介绍这个    static final int CONDITION = -2;    /**     * waitStatus value to indicate the next acquireShared should     * unconditionally propagate     */    // 同样的不分析，略过吧    static final int PROPAGATE = -3;    // =====================================================    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。    volatile int waitStatus;    // 前驱节点的引用    volatile Node prev;    // 后继节点的引用    volatile Node next;    // 这个就是线程本尊    volatile Thread thread;&#125;</code></pre><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p><p><img src="/2021/05/03/aqs-chu-jian/aqs-0.png" alt="aqs-0"></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><pre><code class="line-numbers language-java">// 我用个web开发中的service概念吧public class OrderService &#123;    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个    private static ReentrantLock reentrantLock = new ReentrantLock(true);    public void createOrder() &#123;        // 比如我们同一时间，只允许一个线程创建订单        reentrantLock.lock();        // 通常，lock 之后紧跟着 try 语句        try &#123;            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来            // 执行代码...            // 执行代码...            // 执行代码...        &#125; finally &#123;            // 释放锁            reentrantLock.unlock();        &#125;    &#125;&#125;</code></pre><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><pre><code class="line-numbers language-java">abstract static class Sync extends AbstractQueuedSynchronizer &#123;&#125;</code></pre><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><pre><code class="line-numbers language-java">public ReentrantLock(boolean fair) &#123;    sync = fair ? new FairSync() : new NonfairSync();&#125;</code></pre><h3 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h3><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><pre><code class="line-numbers language-java">static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;      // 争锁    final void lock() &#123;        acquire(1);    &#125;      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。    // 否则，acquireQueued方法会将线程压到队列中    public final void acquire(int arg) &#123; // 此时 arg == 1        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试        // 因为有可能直接就成功了呢，也就不需要进队列排队了，        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)        if (!tryAcquire(arg) &amp;&amp;            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;              selfInterrupt();        &#125;    &#125;    /**     * Fair version of tryAcquire.  Don&#39;t grant access unless     * recursive call or no waiters or is first.     */    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取    protected final boolean tryAcquire(int acquires) &#123;        final Thread current = Thread.currentThread();        int c = getState();        // state == 0 此时此刻没有线程持有锁        if (c == 0) &#123;            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，            // 看看有没有别人在队列中等了半天了            if (!hasQueuedPredecessors() &amp;&amp;                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=                // 因为刚刚还没人的，我判断过了                compareAndSetState(0, acquires)) &#123;                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1        // 这里不存在并发问题        else if (current == getExclusiveOwnerThread()) &#123;            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁        // 回到上面一个外层调用方法继续看:        // if (!tryAcquire(arg)         //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))         //     selfInterrupt();        return false;    &#125;    // 假设tryAcquire(arg) 返回false，那么代码将执行：      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)    /**     * Creates and enqueues node for current thread and given mode.     *     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared     * @return the new node     */    // 此方法的作用是把线程包装成node，同时进入到队列中    // 参数mode此时是Node.EXCLUSIVE，代表独占模式    private Node addWaiter(Node mode) &#123;        Node node = new Node(Thread.currentThread(), mode);        // Try the fast path of enq; backup to full enq on failure        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后        Node pred = tail;        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)        if (pred != null) &#123;             // 将当前的队尾节点，设置为自己的前驱             node.prev = pred;             // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴            if (compareAndSetTail(pred, node)) &#123;                 // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了                pred.next = node;                // 线程入队了，可以返回了                return node;            &#125;        &#125;        // 仔细看看上面的代码，如果会到这里，        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的        enq(node);        return node;    &#125;    /**     * Inserts node into queue, initializing if necessary. See picture above.     * @param node the node to insert     * @return node&#39;s predecessor     */    // 采用自旋的方式入队    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的    private Node enq(final Node node) &#123;        for (;;) &#123;            Node t = tail;            // 之前说过，队列为空也会进来这里            if (t == null) &#123; // Must initialize                // 初始化head节点                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢                if (compareAndSetHead(new Node()))                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了                    // 这个时候有了head，但是tail还是null，设置一下，                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了                    tail = head;            &#125; else &#123;                // 下面几行，和上一个方法 addWaiter 是一样的，                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排                node.prev = t;                if (compareAndSetTail(t, node)) &#123;                    t.next = node;                    return t;                &#125;            &#125;        &#125;    &#125;    // 现在，又回到这段代码了    // if (!tryAcquire(arg)     //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))     //     selfInterrupt();    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了    final boolean acquireQueued(final Node node, int arg) &#123;        boolean failed = true;        try &#123;            boolean interrupted = false;            for (;;) &#123;                final Node p = node.predecessor();                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列                // 所以当前节点可以去试抢一下锁                // 这里我们说一下，为什么可以去试试：                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state                if (p == head &amp;&amp; tryAcquire(arg)) &#123;                    setHead(node);                    p.next = null; // help GC                    failed = false;                    return interrupted;                &#125;                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = true;            &#125;        &#125; finally &#123;            // 什么时候 failed 会为 true???            // tryAcquire() 方法抛异常的情况            if (failed)                cancelAcquire(node);        &#125;    &#125;    /**     * Checks and updates status for a node that failed to acquire.     * Returns true if thread should block. This is the main signal     * control in all acquire loops.  Requires that pred == node.prev     *     * @param pred node&#39;s predecessor holding status     * @param node the node     * @return &#123;@code true&#125; if thread should block     */    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;        int ws = pred.waitStatus;        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true        if (ws == Node.SIGNAL)            /*             * This node has already set status asking a release             * to signal it, so it can safely park.             */            return true;        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的        if (ws &gt; 0) &#123;            /*             * Predecessor was cancelled. Skip over predecessors and             * indicate retry.             */            do &#123;                node.prev = pred = pred.prev;            &#125; while (pred.waitStatus &gt; 0);            pred.next = node;        &#125; else &#123;            /*             * waitStatus must be 0 or PROPAGATE.  Indicate that we             * need a signal, but don&#39;t park yet.  Caller will need to             * retry to make sure it cannot acquire before parking.             */            // 仔细想想，如果进入到这个分支意味着什么            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        &#125;        // 这个方法返回 false，那么会再走一次 for 循序，        //     然后再次进来此方法，此时会从第一个分支返回 true        return false;    &#125;    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)    // 这个方法结束根据返回值我们简单分析下：    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看    // 跳回到前面是这个方法    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;    //                parkAndCheckInterrupt())    //                interrupted = true;    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，    // 那么需要执行parkAndCheckInterrupt():    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======    private final boolean parkAndCheckInterrupt() &#123;        LockSupport.park(this);        return Thread.interrupted();    &#125;    // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。&#125;</code></pre><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h3 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h3><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><pre><code class="line-numbers language-java">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了public void unlock() &#123;    sync.release(1);&#125;public final boolean release(int arg) &#123;    // 往后看吧    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;// 回到ReentrantLock看tryRelease方法protected final boolean tryRelease(int releases) &#123;    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 是否完全释放锁    boolean free = false;    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉    if (c == 0) &#123;        free = true;        setExclusiveOwnerThread(null);    &#125;    setState(c);    return free;&#125;/** * Wakes up node&#39;s successor, if one exists. * * @param node the node */// 唤醒后继节点// 从上面调用处知道，参数node是head头结点private void unparkSuccessor(Node node) &#123;    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    int ws = node.waitStatus;    // 如果head节点当前waitStatus&lt;0, 将其修改为0    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    &#125;    if (s != null)        // 唤醒线程        LockSupport.unpark(s.thread);&#125;</code></pre><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><pre><code class="line-numbers language-java">private final boolean parkAndCheckInterrupt() &#123;    LockSupport.park(this); // 刚刚线程被挂起在这里了    return Thread.interrupted();&#125;// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</code></pre><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577">关于CLH的介绍</a>，写得简单明了。</li></ol><h3 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h3><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><pre><code class="line-numbers language-java">private Node enq(final Node node) &#123;    for (;;) &#123;        Node t = tail;        if (t == null) &#123; // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;            &#125;        &#125;    &#125;&#125;</code></pre><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><p><img src="/2021/05/03/aqs-chu-jian/aqs-1.png" alt="aqs-1"></p><p>然后线程 2 入队：</p><p><img src="/2021/05/03/aqs-chu-jian/aqs-2.png" alt="aqs-2"></p><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><p><img src="/2021/05/03/aqs-chu-jian/aqs-3.png" alt="aqs-3"></p><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><p>（全文完）</p><h3 id="一位读者画的流程图"><a href="#一位读者画的流程图" class="headerlink" title="一位读者画的流程图"></a>一位读者画的流程图</h3><blockquote><p>starkZH ：</p><p>我画了下acquire的实现流程图，希望能帮助大家梳理下</p></blockquote><p><img src="/2021/05/03/aqs-chu-jian/602f37927d9c081db9a6d12c.png" alt="acquire实现流程图"></p><h2 id="篇二、-Java-并发高频面试题：聊聊你对-AQS-的理解？"><a href="#篇二、-Java-并发高频面试题：聊聊你对-AQS-的理解？" class="headerlink" title="篇二、 Java 并发高频面试题：聊聊你对 AQS 的理解？"></a><strong>篇二、 Java 并发高频面试题：聊聊你对 AQS 的理解？</strong></h2><p>2019.10.06 22:53 4278浏览</p><p>这篇文章，我们来聊聊面试时一个比较有杀伤力的问题：<strong>聊聊你对AQS的理解？</strong></p><p>之前有同学反馈，去互联网公司面试，面试官聊到并发时就问到了这个问题。当时那位同学内心估计受到了一万点伤害。。。</p><p>因为首先，很多人可能连AQS是什么都不知道。或者仅仅是听说过AQS这个名词，但是可能连全称怎么拼写都不知道。</p><p>更有甚者，可能会说：AQS？是不是一种思想？我们平时开发怎么来用AQS？</p><p>总结起来，很多同学都对AQS有一种云里雾里的感觉，如果用搜索引擎查一下AQS是什么，估计看几篇文章就直接放弃了，因为密密麻麻的文字，实在是看不懂！</p><p>所以基于上述痛点，这篇文章就用最简单的大白话配合N多张手绘图，给大家讲清楚AQS到底是什么？</p><p>让各位同学面试被问到这个问题时，不至于不知所措。</p><h3 id="二、ReentrantLock和AQS的关系"><a href="#二、ReentrantLock和AQS的关系" class="headerlink" title="二、ReentrantLock和AQS的关系"></a><strong>二、ReentrantLock和AQS的关系</strong></h3><p>首先来看看，如果用java并发包下的ReentrantLock来加锁和释放锁，是个什么样的感觉？</p><p>这个学过java的同学应该都会吧，毕竟是java并发基本API的使用，我们直接看一下代码：</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ff300001fbcc04740244.jpg" alt="http://img1.sycdn.imooc.com/5d99ff300001fbcc04740244.jpg"></p><p>上面那段代码应该不难理解，无非就是搞一个Lock对象，然后加锁和释放锁。</p><p>你这时可能会问，这个跟AQS有啥关系？</p><p>关系大了去了！因为java并发包下很多API都是基于AQS来实现的加锁和释放锁等功能的，AQS是java并发包的基础类。</p><p>举个例子，比如说ReentrantLock、ReentrantReadWriteLock底层都是基于AQS来实现的。</p><p>那么AQS的全称是什么呢？</p><p><strong>AbstractQueuedSynchronizer，抽象队列同步器</strong></p><p>给大家画一个图，看一下ReentrantLock和AQS之间的关系。</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ff400001c00005450164.jpg" alt="http://img1.sycdn.imooc.com/5d99ff400001c00005450164.jpg"></p><p>我们看上图，说白了，ReentrantLock内部包含了一个AQS对象，也就是AbstractQueuedSynchronizer类型的对象。</p><p>这个AQS对象就是ReentrantLock可以实现加锁和释放锁的关键性的核心组件。</p><h3 id="三、ReentrantLock加锁和释放锁的底层原理"><a href="#三、ReentrantLock加锁和释放锁的底层原理" class="headerlink" title="三、ReentrantLock加锁和释放锁的底层原理"></a><strong>三、ReentrantLock加锁和释放锁的底层原理</strong></h3><p>好了，现在如果有一个线程过来尝试用ReentrantLock的lock()方法进行加锁，会发生什么事情？</p><p>很简单，这个AQS对象内部有一个核心的变量叫做<strong>state</strong>，是int类型的，代表了<strong>加锁的状态</strong>。</p><p>初始状态下，这个state的值是0。</p><p>另外，这个AQS内部还有一个<strong>关键变量</strong>，用来记录<strong>当前加锁的是哪个线程</strong>，初始化状态下，这个变量是null。</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ff60000164b005240214.jpg" alt="http://img1.sycdn.imooc.com/5d99ff60000164b005240214.jpg"></p><p>接着线程跑过来调用ReentrantLock的lock()方法尝试进行加锁，这个加锁的过程，直接就是用CAS操作将state值从0变为1。</p><p>（关于CAS，之前专门有文章做过详细阐述，大家可以自行阅读了解）</p><p>如果之前没人加过锁，那么state的值肯定是0，此时线程1就可以加锁成功。</p><p>一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己。所以大家看下面的图，就是线程1跑过来加锁的一个过程。</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ff700001559506300260.jpg" alt="http://img1.sycdn.imooc.com/5d99ff700001559506300260.jpg"></p><p>其实看到这儿，大家应该对所谓的AQS有感觉了。说白了，就是并发包里的一个核心组件，里面有state变量、加锁线程变量等核心的东西，维护了加锁状态。</p><p>你会发现，ReentrantLock这种东西只是一个外层的API，<strong>内核中的锁机制实现都是依赖AQS组件的</strong>。</p><p>这个ReentrantLock之所以用Reentrant打头，意思就是他是一个可重入锁。</p><p>可重入锁的意思，就是你可以对一个ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次，叫做可重入加锁。</p><p>大家看明白了那个state变量之后，就知道了如何进行可重入加锁！</p><p>其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么他自己就可以可重入多次加锁，每次加锁就是把state的值给累加1，别的没啥变化。</p><p>接着，如果线程1加锁了之后，线程2跑过来加锁会怎么样呢？</p><p><strong>我们来看看锁的互斥是如何实现的？</strong></p><p>线程2跑过来一下看到，哎呀！state的值不是0啊？所以CAS操作将state从0变为1的过程会失败，因为state的值当前为1，说明已经有人加锁了！</p><p>接着线程2会看一下，是不是自己之前加的锁啊？当然不是了，<strong>“加锁线程”</strong>这个变量明确记录了是线程1占用了这个锁，所以线程2此时就是加锁失败。</p><p>给大家来一张图，一起来感受一下这个过程：</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ff80000104d006530410.jpg" alt="http://img2.sycdn.imooc.com/5d99ff80000104d006530410.jpg"></p><p>接着，线程2会将自己放入AQS中的一个等待队列，因为自己尝试加锁失败了，此时就要将自己放入队列中来等待，等待线程1释放锁之后，自己就可以重新尝试加锁了</p><p>所以大家可以看到，AQS是如此的核心！AQS内部还有一个等待队列，专门放那些加锁失败的线程！</p><p>同样，给大家来一张图，一起感受一下：</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ff8e0001bef806550358.jpg" alt="http://img1.sycdn.imooc.com/5d99ff8e0001bef806550358.jpg"></p><p>接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！<strong>他释放锁的过程非常的简单</strong>，就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null！</p><p>整个过程，参见下图：</p><p>接下来，会从<strong>等待队列的队头唤醒线程2重新尝试加锁。</strong></p><p>好！线程2现在就重新尝试加锁，这时还是用CAS操作将state从0变为1，此时就会成功，成功之后代表加锁成功，就会将state设置为1。</p><p>此外，还要把<strong>“加锁线程”</strong>设置为线程2自己，同时线程2自己就从等待队列中出队了。</p><p>最后再来一张图，大家来看看这个过程。</p><p><img src="/2021/05/03/aqs-chu-jian/5d99ffb80001bd6406710405.jpg" alt="http://img2.sycdn.imooc.com/5d99ffb80001bd6406710405.jpg"></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h3><p>OK，本文到这里为止，基本借着ReentrantLock的加锁和释放锁的过程，给大家讲清楚了其底层依赖的AQS的核心原理。</p><p>基本上大家把这篇文章看懂，以后再也不会担心面试的时候被问到：谈谈你对AQS的理解这种问题了。</p><p>其实一句话总结：<strong>AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。</strong></p><p><strong>它包含了state变量、加锁线程、等待队列等并发中的核心组件。</strong></p><p><strong>END</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. 数组中的第K个最大元素-中等</title>
      <link href="2021/05/03/215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng/"/>
      <url>2021/05/03/215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用二分加快排</p><p>利用二分减少查询次数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="line-numbers language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;        int l = 0, r = nums.length-1, target = nums.length - k;        while (l &lt; r) &#123;            int mid  = partition(nums, l, r);            if (mid == target) &#123;                return nums[mid];            &#125; else if (mid &lt; target) &#123;                l = mid + 1;            &#125; else if (mid &gt; target) &#123;                r = mid - 1;            &#125;        &#125;        return nums[l];    &#125;    public int partition (int[] nums, int low, int high) &#123;        int pivot = nums[low];        while (low &lt; high) &#123;            while(low &lt; high &amp;&amp; nums[high] &gt;= pivot) --high;            if (low &lt; high) nums[low] = nums[high];            while(low &lt; high &amp;&amp; nums[low] &lt;= pivot) ++low;            if (low &lt; high) nums[high] = nums[low];        &#125;        nums[low] = pivot;        return low;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵中的路径+Java只有值传递？</title>
      <link href="2021/04/25/ju-zhen-zhong-de-lu-jing-java-zhi-you-zhi-chuan-di/"/>
      <url>2021/04/25/ju-zhen-zhong-de-lu-jing-java-zhi-you-zhi-chuan-di/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://www.nowcoder.com/practice/69fe7a584f0a445da1b6652978de5c38?tpId=13&tqId=11218&tab=answerKey&from=cyc_github">矩阵中的路径</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="错误题解"><a href="#错误题解" class="headerlink" title="错误题解"></a>错误题解</h3><pre><code class="line-numbers language-java">package com.xu.swordFingerOffer.矩阵中的路径;import java.util.*;public class Solution &#123;    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param matrix string字符串      * @param rows int整型      * @param cols int整型      * @param str string字符串      * @return bool布尔型     */    public boolean hasPath (String matrix, int rows, int cols, String str) &#123;        // write code here        char[] array = matrix.toCharArray();        char[] strs = str.toCharArray();        boolean find = false;        boolean[] visited = new boolean[rows*cols];        for (int i = 0; i &lt; rows; i++) &#123;            for (int j = 0; j &lt; cols; j++) &#123;                dfs(i, j, 0, array, strs, visited, find, rows, cols);            &#125;        &#125;        return find;    &#125;    private void dfs (int i, int j, int pos, char[] matrix, char[] str, boolean[] visited, boolean find, int rows, int cols) &#123;        if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols) &#123;            return;        &#125;        int visiting_pos = i*cols + j;        if (visited[visiting_pos] || find || matrix[visiting_pos] != str[pos]) &#123;            return;        &#125;        if (pos == str.length-1) &#123;            find = true;            return;        &#125;        visited[visiting_pos] = true;//修改当前节点        //递归子节点        dfs(i + 1, j,pos + 1,  matrix, str, visited, find, rows, cols);        dfs(i - 1, j,pos + 1,  matrix, str, visited, find, rows, cols);        dfs(i, j + 1,pos + 1,  matrix, str, visited, find, rows, cols);        dfs(i, j - 1,pos + 1,  matrix, str, visited, find, rows, cols);        visited[visiting_pos] = false;//回溯到当前状态    &#125;&#125;</code></pre><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>Java基本类型是值传递</p><p>定义的boolean find = false;</p><p>在递归函数中没有被改变</p><h3 id="正确题解"><a href="#正确题解" class="headerlink" title="正确题解"></a>正确题解</h3><pre><code class="line-numbers language-java">package com.xu.swordFingerOffer.矩阵中的路径;import java.util.*;public class Solution &#123;    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param matrix string字符串      * @param rows int整型      * @param cols int整型      * @param str string字符串      * @return bool布尔型     */    public boolean hasPath (String matrix, int rows, int cols, String str) &#123;        // write code here        char[] array = matrix.toCharArray();        char[] strs = str.toCharArray();        boolean[] visited = new boolean[rows*cols];        for (int i = 0; i &lt; rows; i++) &#123;            for (int j = 0; j &lt; cols; j++) &#123;                if (dfs(i, j, 0, array, strs, visited, rows, cols))                    return true;            &#125;        &#125;        return false;    &#125;    private boolean dfs (int i, int j, int pos, char[] matrix, char[] str, boolean[] visited, int rows, int cols) &#123;        //越界        if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols) &#123;            return false;        &#125;        int visiting_pos = i*cols + j;        //已拜访过或者不符合条件        if (visited[visiting_pos]|| matrix[visiting_pos] != str[pos]) &#123;            return false;        &#125;        //成功找到        if (pos == str.length-1) &#123;            return true;        &#125;        visited[visiting_pos] = true;//修改当前节点        //递归子节点        if (            dfs(i + 1, j,pos + 1,  matrix, str, visited, rows, cols) ||            dfs(i - 1, j,pos + 1,  matrix, str, visited, rows, cols) ||            dfs(i, j + 1,pos + 1,  matrix, str, visited, rows, cols) ||            dfs(i, j - 1,pos + 1,  matrix, str, visited, rows, cols)        ) return true;        visited[visiting_pos] = false;//回溯到当前状态        return false;    &#125;&#125;</code></pre><h2 id="Java只有值传递？"><a href="#Java只有值传递？" class="headerlink" title="Java只有值传递？"></a>Java只有值传递？</h2><p>Java中只有值传递流派的大致意思是</p><blockquote><p>值传递，不论传递的参数类型是值类型还是引用类型，都会在调用栈上创建一个形参的副本。不同的是，对于值类型来说，复制的就是整个原始值的复制。而对于引用类型来说，由于在调用栈中只存储对象的引用，因此复制的只是这个引用，而不是原始对象。</p></blockquote><p>简单来说， 就是浅拷贝。</p><blockquote><p>浅拷贝：基本类型传递值， 引用类型传递的值是引用。</p></blockquote><p>无论是值传递还是引用传递，其实都是一种求值策略(Evaluation strategy)。在求值策略中，还有一种叫做按共享传递(call by sharing)。其实Java中的参数传递严格意义上说应该是按共享传递。</p><blockquote><p> 按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。</p></blockquote><p>再看看JVM内存模型</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><img src="/2021/04/25/ju-zhen-zhong-de-lu-jing-java-zhi-you-zhi-chuan-di/image-20210425112147763.png" alt="image-20210425112147763"></p><p>所以， Java只有值传递， 大概可以理解为**基本类型传递值， 引用类型传递的值是引用(refrence)**。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 深搜 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>居合斩！二分查找</title>
      <link href="2021/04/23/ju-he-zhan-er-fen-cha-zhao/"/>
      <url>2021/04/23/ju-he-zhan-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>二分查找真的很简单吗？并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：</p><blockquote><p>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky…</p></blockquote><p>这句话可以这样理解：<strong>思路很简单，细节是魔鬼。</strong></p><h3 id="找到一个数"><a href="#找到一个数" class="headerlink" title="找到一个数"></a>找到一个数</h3><pre><code class="line-numbers language-java">private static int binarySearch(int [] array, int target) &#123;    int l = 0, r = array.length-1;    while (l &lt;= r) &#123;        int m = l + (r - l) / 2;        if (array[m] == target) &#123;            return m;        &#125; else if (array[m] &gt; target) &#123;            r = m - 1;        &#125; else if (array[m] &lt; target)&#123;            l = m + 1;        &#125;    &#125;    return -1;&#125;</code></pre><blockquote><p><em>1</em>. 为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？</p><p>答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)。</p></blockquote><h3 id="如果存在多个，找到左边界"><a href="#如果存在多个，找到左边界" class="headerlink" title="如果存在多个，找到左边界"></a>如果存在多个，找到左边界</h3><p><strong>需要满足数组是非降序数组</strong></p><pre><code class="line-numbers language-java">private static int binarySearchLeft(int [] array, int target) &#123;    int l = 0, r = array.length;    while (l &lt; r) &#123;        int m = l + (r - l) / 2;        if (array[m] &gt;= target) &#123;            r = m;        &#125; else if (array[m] &lt; target) &#123;            l = m + 1;        &#125;    &#125;    return l;&#125;//未找到int find = binarySearchLeft(array, target);if (find == array.length || array[find] != target)    return “未找到”;</code></pre><h3 id="如果存在多个，找到右边界"><a href="#如果存在多个，找到右边界" class="headerlink" title="如果存在多个，找到右边界"></a>如果存在多个，找到右边界</h3><p><strong>需要满足数组是非降序数组</strong></p><pre><code class="line-numbers language-java">private static int binarySearchRight(int [] array, int target) &#123;    int l = 0, r = array.length;    while (l &lt; r) &#123;        int m = l + (r - l) / 2;        if (array[m] &lt;= target) &#123;            l = m + 1;        &#125; else if (array[m] &gt; target) &#123;            r = m;        &#125;    &#125;    return r-1;&#125;//未找到int find = binarySearchRight(array, target);if (find == array.length || array[find] != target)    return “未找到”;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表中重复的结点</title>
      <link href="2021/04/19/shan-chu-lian-biao-zhong-chong-fu-de-jie-dian/"/>
      <url>2021/04/19/shan-chu-lian-biao-zhong-chong-fu-de-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>&#123;1,2,3,3,4,4,5&#125;</code></pre><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><pre><code>&#123;1,2,5&#125;</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双前指针+HashSet</p><p>HashSet检查是否重复， 用prepre.next = pHead.next进行删除</p><p>之所以要使用prepre， 是因为题目要求<code>重复的结点不保留</code>， 使用prepre记录出现重复节点的的前一个节点， 比如{1， 2， 2}， 则prepre就指向1</p><p>使用dummy虚拟节点， 使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy-&gt;next 即可</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="line-numbers language-java">package com.xu.删除链表中重复的结点;import com.xu.entity.ListNode;import java.util.HashSet;/* public class ListNode &#123;    int val;    ListNode next = null;    ListNode(int val) &#123;        this.val = val;    &#125;&#125;*/public class Solution &#123;    public ListNode deleteDuplication(ListNode pHead) &#123;        if (pHead == null || pHead.next == null)&#123;            return pHead;        &#125;        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        ListNode prepre, pre, dummy = new ListNode(0);        dummy.next = pHead;        prepre = dummy;        pre = dummy;        while (pHead != null) &#123;            if (set.contains(pHead.val)) &#123;                prepre.next = pHead.next;                pre = prepre;            &#125; else &#123;                set.add(pHead.val);                prepre = pre;                pre = pHead;            &#125;            pHead = pHead.next;        &#125;        return dummy.next;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计管理系统1.0.0</title>
      <link href="2021/04/17/bi-ye-she-ji-guan-li-xi-tong-1-0-0/"/>
      <url>2021/04/17/bi-ye-she-ji-guan-li-xi-tong-1-0-0/</url>
      
        <content type="html"><![CDATA[<h2 id="设计一个毕业设计管理系统"><a href="#设计一个毕业设计管理系统" class="headerlink" title="设计一个毕业设计管理系统"></a>设计一个毕业设计管理系统</h2><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a><a href="https://github.com/bwhyman/graduation-process-management">系统要求</a></h2><h3 id="graduation-process-management"><a href="#graduation-process-management" class="headerlink" title="graduation-process-management"></a>graduation-process-management</h3><h3 id="2021-02-16"><a href="#2021-02-16" class="headerlink" title="2021.02.16"></a>2021.02.16</h3><h4 id="task-教师更新描述信息"><a href="#task-教师更新描述信息" class="headerlink" title="task - 教师更新描述信息"></a>task - 教师更新描述信息</h4><p>patch /api/teachers/info</p><h4 id="task-手动添加删除教师-学生"><a href="#task-手动添加删除教师-学生" class="headerlink" title="task - 手动添加删除教师/学生"></a>task - 手动添加删除教师/学生</h4><p>post /api/director/teachers</p><p>手动添加学生，使用导入表格相同接口，将学生对象存数组<br>post /api/director/students</p><p>delete /api/director/teachers/{tid}<br>delete /api/director/students/{sid}</p><h4 id="task-创建选导师任务"><a href="#task-创建选导师任务" class="headerlink" title="task - 创建选导师任务"></a>task - 创建选导师任务</h4><p>director，创建任务，下拉选择，选导师任务。加载选导师组件。<br>所有导师带学生数，必须与学生总数匹配，否则无法创建选导师任务。</p><p>前端，提供2处可修改教师带学生数。<br>1.在教师列表(教师维护组件中)，将每个教师所带学生数显式为输入框，某处显式总数与当前学生总数的比较，提供提交按钮，</p><p>2.选导师任务组件。vuex要缓存一些数据。<br>提供数据：教师列表，学生总数<br>教师列表：仅显式姓名与带学生数，带学生数是输入框，先判断vuex是否有teachers，有获取长度，没有则请求：get /api/common/teachers<br>学生总数：先判断vuex中是否有students，没有则请求：get /api/common/students/count</p><p>2处提交更新请求：patch /api/director/teachers/quantity</p><p>比较相等后，允许创建任务。后端补全任务类型，创建者信息<br>post /api/director/tasks/choice</p><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><p>系统以选择导师，收集整理学生/导师提交的文件为主，发通知为辅(QQ群发通知更便捷，无需学生经常登录系统查看消息)。<br>所有模板文档，传qq群更方便吧？</p><p>毕设主要功能过程</p><ul><li>导入导师，导入学生</li><li>导师添加毕设方向等简介，可为空</li><li>启动学生选导师任务，注意并发请求。这个任务与普通任务不同，必须有单独选项，前端有单独组件，无法抽象</li><li>录入毕设题目。导师与学生单独讨论拟定论文题目(导师建自己的毕设QQ群等)</li><li>专业讨论题目内容是否冲突是否合适，导师再次修改确定毕设题目内容。学生无修改题目功能。以上应该11月中旬前结束</li><li>答辩分组，如何分？导入表格，秘书手动选择本组学生？</li><li>下发毕设开题任务，可能是通知等等，也可能没有此任务，下发分组表格，也可能qq群发</li><li>任务，全体，下发开题答辩报告模板</li><li>任务，全体，下发开题答辩记录模板</li><li>任务，学生，提交开题报告，同组导师可查看</li><li>任务，教师，开题答辩后，提交对本组每个学生的答辩意见，非文档，文本记录即可</li><li>任务，学生，提交开题答辩记录。学生查看开题答辩意见，复制评委教师意见，给出回答，提交文档。开题答辩记录文档，要作为毕业答辩考察依据。设置文件命名规则，可打包下载，主任</li><li>任务，全体，下发期中检查报告模板</li><li>任务，学生，提交期中检查报告。4月中旬</li><li>任务，学生，上传查重版毕设，word版，5月末。文件命名规则，打包下载</li><li>任务，教师，毕业答辩后，提交答辩意见，同上</li><li>任务，学生，提交毕业答辩记录，同上。文件命名规则，打包下载</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>功能，适合于按角色划分</p><p>需要制定，导入教师的表格，直接给权限列，没填算默认值；导入学生表格，前端直接权限赋值。学生分组表格？</p><p>功能实现，统一上传文件根目录，分任务模板目录，任务目录。目录下按，ID-任务名称，创建目录。创建任务时，业务逻辑层先处理保存数据操作，在保存文件，异常可使数据同时回滚</p><h5 id="学生"><a href="#学生" class="headerlink" title="学生"></a>学生</h5><p>学生资料要求提供手机号，修改密码</p><p>提交各种文档报告</p><h5 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h5><p>可重置自己学生密码；查看/修改自己学生信息，毕设信息；</p><p>给出本组学生的开题/毕业答辩意见</p><p>查看所有学生任务的完成情况，即查询当前未完成学生。如果有自己带的学生，导师负责联系催促</p><h5 id="主任"><a href="#主任" class="headerlink" title="主任"></a>主任</h5><p>包含以上所有功能，也许给出本组学生答辩意见等等</p><p>可修改普通导师权限为主任</p><p>发布任务，提供任务级别，是否有上一级任务节点，仅支持2级即可</p><p>关闭任务；</p><p>修改任务信息，时间/标题内容/等等</p><p>删除任务，直接删除任务对应的上传目录。即任务的所有文件</p><p>添加删除学生。手动，导入的学生可能有变化</p><p>修改导师带学生人数。前端，应给出当前学生数，与导师带学生总人数，的比较，后端给统计数据</p><h5 id="超级管理员"><a href="#超级管理员" class="headerlink" title="超级管理员"></a>超级管理员</h5><p>初始化时最高权限，导入教师表格，初始化教师权限，导入学生</p><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>前端左导航分2部分，固定功能，任务列表</p><p>固定的管理功能。比如导师查看当前学生，修改学生信息；主任创建任务，修改/删除/关闭任务去已经创建的任务中操作，无权限的看不到编辑按钮</p><p>动态任务列表。不同角色用户看见自己的任务列表，动态生成的任务列表，最高2级</p><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p>所有表，包含ID(mybatis-plus雪花算法自动生成)；update_time，随修改自动修改，default current_timestamp on update current_timestamp；无外键加索引</p><p>id,BIGINT(19)</p><p>update_time default current_timestamp on update current_timestamp</p><p>用户，user</p><ul><li>账号/密码，学号，员工号. number, varchar(12)</li><li>姓名.name, varchar(8)</li><li>角色值，role, int</li></ul><p>角色值，固定，非数据表，减少表数</p><ul><li>1，学生</li><li>2，导师</li><li>4，主任</li><li>9，超级管理员</li></ul><p>学生，student</p><ul><li>用户ID user_id, BIGINT(19)</li><li>班级. clazz, varchar(16)</li><li>导师ID. teacher_id, BIGINT(19)</li><li>小组, group, int</li><li>课设题目,topic, varchar(45)</li></ul><p>教师，teacher</p><ul><li>用户ID. user_id, BIGINT(19)</li><li>小组. group, smallint</li><li>职称. title, varchar(8)</li><li>指导学生数. quantity, TINYINT(2)</li><li>描述，预指导课设说明要求，提供可选课设题目等。例如，预指导基于Flutter的移动端课设. varchar(45)</li></ul><p>是否可合并成一张用户表？</p><p>任务，task。不可分割的实现单元</p><ul><li>标题. title, varchar(45)</li><li>描述. description, varchar(45)</li><li>开始/结束时间；(结束时间是否有意义，不提交怎么办？当前按自动关闭设计. start_time/end_time, DATETIME</li><li>状态。0未开始，1开始，2结束。status，int</li><li>任务类型，type，int。任务类型，详细信息查看types.md文档</li><li>完成角色，任务由那种角色完成。默认1。也有对教师下发任务。target，1学生，2教师。int</li><li>发布者ID，user_id, BIGINT(19)</li><li>模板文件名称。单独的模板文件目录，去找同名文件，可覆盖，文件名冲突要有提示。filename，varchar(45)</li><li>上传文件名称规则，js的字符串数组[]。详细信息查看types.md文档。一旦确定不可修改，否则，如果学生已经上传，文件已经由此命名，修改会很麻烦。可以直接删除任务，创建新任务</li><li>文件类型后缀，*.doc, *.docx等。直接存字符串。ext_name, varchar(8)</li></ul><p>学生任务，student_task，学生与任务中间表</p><ul><li>学生ID</li><li>任务ID</li><li>任务描述。description, varchar(45)</li><li>文件名称，上传时，前端直接基于任务命名规范拼接文件名称。拼接的文件名称。filename，varchar(45)</li></ul><p>教师答辩意见，teacher_suggestion，教师对指定任务(开题/毕业答辩)的意见</p><ul><li>教师ID</li><li>学生ID</li><li>任务ID</li><li>问题，对指定毕设，suggestion，description, varchar(45)</li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>就这点功能，不必分模块了吧<br>没加swagger，前后端无法联网联调。并行开发，使用md文档，github分享请求/响应数据结构<br>component包下为原工具类，按单例组件设计<br>entity直接当do层<br>修改application.yml/generatorConfig.xml数据源配置<br>在Maven视图/plugins/mybatis-generator，运行mybatis-generator:generate生成model/mapper<br>每次均创建model覆盖，但仅为新数据表创建mapper</p><p>mybatis-plus全局雪花算法生成ID；注入乐观锁拦截器<br>Jackson序列化时忽略空值属性<br>redis后期看情况加<br>其他自己加</p><h2 id="一些文件"><a href="#一些文件" class="headerlink" title="一些文件"></a>一些文件</h2><h3 id="type-md"><a href="#type-md" class="headerlink" title="type.md"></a>type.md</h3><pre><code class="line-numbers language-markdown">role，角色值，固定，非数据表，减少表数   - 1，学生 - 2，导师 - 4，主任 - 9，超级管理员任务类型，非数据表 - 1，新闻公告类，无互交的 - 2，文件，如果任务要求上传多文件，分解任务 - 3，选导师 - 4，答辩意见，对应教师。教师写自己小组毕设开题/答辩问题任务文件命名规范 按字符串数组[]保存在数据库，由前端解析，与后端无关  @开头字符串，需要动态解析；其他为预设直接读取；也可手动输入  例如。学生姓名-学号-开题答辩记录，\[&quot;@学生姓名&quot;, &quot;@学号&quot;, &quot;开题答辩记录&quot;\] - @指导教师 - @学生姓名 - @学号 - @毕设题目 - 开题报告 - 开题答辩记录 - 毕业答辩记录 - 期中检查表 - 论证报告</code></pre><h2 id="基于RuoYi进行二次开发"><a href="#基于RuoYi进行二次开发" class="headerlink" title="基于RuoYi进行二次开发"></a>基于RuoYi进行二次开发</h2><p>1.官方文档地址：<a href="http://doc.ruoyi.vip/ruoyi-cloud/">http://doc.ruoyi.vip/ruoyi-cloud/</a></p><p>2.项目演示地址：<a href="http://cloud.ruoyi.vip/">http://cloud.ruoyi.vip/</a></p><h2 id="先启动一下RuoYi微服务版试下"><a href="#先启动一下RuoYi微服务版试下" class="headerlink" title="先启动一下RuoYi微服务版试下"></a>先启动一下RuoYi微服务版试下</h2><p>RuoYi数据库推荐使用5.7版本， 华为云上面的数据库是5.7， 就先使用华为云吧</p><blockquote><p>简单的配置不再记录， 跟着RuoYi官方文档做就行， 记录一下复杂的。</p></blockquote><h3 id="配置nacos持久化"><a href="#配置nacos持久化" class="headerlink" title="配置nacos持久化"></a>配置<code>nacos</code>持久化</h3><p>修改<code>conf/application.properties</code>文件，增加支持<code>mysql</code>数据源配置</p><pre><code class="line-numbers language-yml"># db mysqlspring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://114.116.215.89:3306/ry-config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user=rootdb.password=password</code></pre><blockquote><p>提示</p><p>配置文件<code>application.properties</code>是在下载的<code>nacos-server</code>包<code>conf</code>目录下。<br>默认配置单机模式，<code>nacos</code>也集群/多集群部署模式参考 (<a href="https://nacos.io/zh-cn/docs/deployment.html">Nacos支持三种部署模式 (opens new window)</a>)</p></blockquote><p>配置持久化之后， 配置文件就全部持久化到了114.116.215.89:3306/ry-config， 即华为云的数据库里的ry-config里</p><h3 id="启动nacos"><a href="#启动nacos" class="headerlink" title="启动nacos"></a>启动nacos</h3><ol><li><p>进入命令行模式</p><pre><code class="line-numbers language-shell">cmd G:\Environment\nacos\bin</code></pre></li><li><p>启动nacos(以单体模式启动)</p><pre><code class="line-numbers language-shell">startup.cmd -m standalone</code></pre></li></ol><p>配置完nacos持久化后别忘了在<a href="http://localhost:8848/nacos/%E4%B8%8B%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81redis...%EF%BC%89">http://localhost:8848/nacos/下修改配置文件（配置数据源、redis...）</a></p><p><img src="/2021/04/17/bi-ye-she-ji-guan-li-xi-tong-1-0-0/image-20210415190911549.png" alt="image-20210415190911549"></p><h3 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h3><ol><li><p>进入命令行模式</p><pre><code class="line-numbers language-shell">cmd G:\Environment\redis6</code></pre></li><li><p>启动Redis</p><pre><code class="line-numbers language-shell">redis-server.exe redis.conf</code></pre></li></ol><p>我在redis.conf设置了requirepass， 需要在配置中心的yml文件里配置redis密码</p><h3 id="启动运行基础模块"><a href="#启动运行基础模块" class="headerlink" title="启动运行基础模块"></a>启动运行基础模块</h3><p>（启动没有先后顺序）</p><ul><li><p>RuoYiGatewayApplication （网关模块 <strong>必须</strong>）</p></li><li><p>RuoYiAuthApplication （认证模块 <strong>必须</strong>）</p></li><li><p>RuoYiSystemApplication （系统模块 <strong>必须</strong>）</p></li><li><p>RuoYiMonitorApplication （监控中心 可选）</p></li><li><p>RuoYiGenApplication （代码生成 可选）</p></li><li><p>RuoYiJobApplication （定时任务 可选）</p></li><li><p>RuoYFileApplication （文件服务 可选）</p></li></ul><h3 id="启动前端"><a href="#启动前端" class="headerlink" title="启动前端"></a>启动前端</h3><pre><code class="line-numbers language-shell">npm installnpm run dev</code></pre><p>运行成功！！！</p><p><img src="/2021/04/17/bi-ye-she-ji-guan-li-xi-tong-1-0-0/image-20210415191523668.png" alt="image-20210415191523668"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计管理系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸识别用户系统接口文档</title>
      <link href="2021/04/10/ren-lian-shi-bie-yong-hu-xi-tong-jie-kou-wen-dang/"/>
      <url>2021/04/10/ren-lian-shi-bie-yong-hu-xi-tong-jie-kou-wen-dang/</url>
      
        <content type="html"><![CDATA[<h1 id="人脸识别用户系统接口文档"><a href="#人脸识别用户系统接口文档" class="headerlink" title="人脸识别用户系统接口文档"></a>人脸识别用户系统接口文档</h1><p>baseUrl: http://域名</p><h2 id="接口列表："><a href="#接口列表：" class="headerlink" title="接口列表："></a>接口列表：</h2><h3 id="1、新增用户人脸标识"><a href="#1、新增用户人脸标识" class="headerlink" title="1、新增用户人脸标识"></a>1、新增用户人脸标识</h3><h4 id="请求URL"><a href="#请求URL" class="headerlink" title="请求URL:"></a>请求URL:</h4><p>http://域名/v1/user/add</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式:"></a>请求方式:</h4><p>get</p><h4 id="参数类型：param"><a href="#参数类型：param" class="headerlink" title="参数类型：param"></a>参数类型：param</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>是否必选</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>face_id</td><td>Y</td><td>string</td><td>人脸的标识码</td></tr><tr><td>city</td><td>Y</td><td>string</td><td>用户首次被识别的城市信息</td></tr></tbody></table><h4 id="返回示例："><a href="#返回示例：" class="headerlink" title="返回示例："></a>返回示例：</h4><pre><code class="line-numbers language-javascript">&#123;  msg:&quot;添加成功&quot;,  status:0&#125;</code></pre><h3 id="2、更新用户备注和姓名"><a href="#2、更新用户备注和姓名" class="headerlink" title="2、更新用户备注和姓名"></a>2、更新用户备注和姓名</h3><h4 id="请求URL-1"><a href="#请求URL-1" class="headerlink" title="请求URL:"></a>请求URL:</h4><p>http://域名/v1/user/update</p><h4 id="请求方式-1"><a href="#请求方式-1" class="headerlink" title="请求方式:"></a>请求方式:</h4><p>get</p><h4 id="参数类型：param-1"><a href="#参数类型：param-1" class="headerlink" title="参数类型：param"></a>参数类型：param</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>是否必选</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>face_id</td><td>Y</td><td>string</td><td>人脸识别码</td></tr><tr><td>userName</td><td>Y</td><td>string</td><td>用户名称</td></tr><tr><td>description</td><td>Y</td><td>string</td><td>备注信息</td></tr></tbody></table><h4 id="返回示例：-1"><a href="#返回示例：-1" class="headerlink" title="返回示例："></a>返回示例：</h4><pre><code class="line-numbers language-javascript">&#123;  status:0,//状态码，0表示正常，-1表示错误  msg:&quot;保存成功&quot;,//返回的消息&#125;</code></pre><h3 id="3、更新用户的收录次数"><a href="#3、更新用户的收录次数" class="headerlink" title="3、更新用户的收录次数"></a>3、更新用户的收录次数</h3><h4 id="请求URL-2"><a href="#请求URL-2" class="headerlink" title="请求URL:"></a>请求URL:</h4><p>http://域名/v1/user/count</p><h4 id="请求方式-2"><a href="#请求方式-2" class="headerlink" title="请求方式:"></a>请求方式:</h4><p>get</p><h4 id="参数类型：param-2"><a href="#参数类型：param-2" class="headerlink" title="参数类型：param"></a>参数类型：param</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>是否必选</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>face_id</td><td>Y</td><td>string</td><td>人脸识别码</td></tr></tbody></table><h4 id="返回示例：-2"><a href="#返回示例：-2" class="headerlink" title="返回示例："></a>返回示例：</h4><pre><code class="line-numbers language-JavaScript">&#123;  data: &#123;  city: &quot;杭州市&quot;,  count: 10,  description: &quot;IT界大佬&quot;,  face_id: &quot;1235314&quot;,  id: 10086,  userName: &quot;小明&quot; &#125;, msg: &quot;操作成功&quot;, status: 0&#125;</code></pre><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL聚簇索引和非聚簇索引的区别</title>
      <link href="2021/04/10/mysql-ju-cu-suo-yin-he-fei-ju-cu-suo-yin-de-qu-bie/"/>
      <url>2021/04/10/mysql-ju-cu-suo-yin-he-fei-ju-cu-suo-yin-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h2><p> <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL?id=myisam-%E5%92%8C-innodb-%E7%9A%84%E5%8C%BA%E5%88%AB">原文</a></p><p><img src="/2021/04/10/mysql-ju-cu-suo-yin-he-fei-ju-cu-suo-yin-de-qu-bie/1618035155300-6a86d4f6-198c-481d-bd22-418d5ed39939.png" alt="image"></p><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><p>5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。小伙子，一定要记好这个 InnoDB ，你每次使用 MySQL 数据库都是用的这个存储引擎吧？</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><h3 id="1-是否支持行级锁"><a href="#1-是否支持行级锁" class="headerlink" title="1.是否支持行级锁"></a>1.是否支持行级锁</h3><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><h3 id="2-是否支持事务"><a href="#2-是否支持事务" class="headerlink" title="2.是否支持事务"></a>2.是否支持事务</h3><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p><h3 id="3-是否支持外键"><a href="#3-是否支持外键" class="headerlink" title="3.是否支持外键"></a>3.是否支持外键</h3><p>MyISAM 不支持，而 InnoDB 支持。</p><p>🌈 拓展一下：</p><p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><h3 id="4-是否支持数据库异常崩溃后的安全恢复"><a href="#4-是否支持数据库异常崩溃后的安全恢复" class="headerlink" title="4.是否支持数据库异常崩溃后的安全恢复"></a>4.是否支持数据库异常崩溃后的安全恢复</h3><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p>🌈 拓展一下：</p><ul><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul><h3 id="5-是否支持-MVCC"><a href="#5-是否支持-MVCC" class="headerlink" title="5.是否支持 MVCC"></a>5.是否支持 MVCC</h3><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p><p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p><h2 id="MyIsam和Innodb"><a href="#MyIsam和Innodb" class="headerlink" title="MyIsam和Innodb"></a>MyIsam和Innodb</h2><h3 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h3><p><img src="/2021/04/10/mysql-ju-cu-suo-yin-he-fei-ju-cu-suo-yin-de-qu-bie/1618034358406-eb4526e4-16a5-4ac1-8327-3c5bd0a81549.png" alt="image.png"></p><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p><img src="/2021/04/10/mysql-ju-cu-suo-yin-he-fei-ju-cu-suo-yin-de-qu-bie/1618034203702-b60181f0-ca2f-4cc1-ab26-353e8f7d9fd7.png" alt="image.png"></p><p>从上面看出</p><p><img src="/2021/04/10/mysql-ju-cu-suo-yin-he-fei-ju-cu-suo-yin-de-qu-bie/1618034559991-db011da1-d80e-4f1b-8acb-8786a48af344.png" alt="image.png"></p><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><blockquote><p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p></blockquote><h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL并发访问的核心机制-MVCC</title>
      <link href="2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/"/>
      <url>2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/</url>
      
        <content type="html"><![CDATA[<h3 id="RC、RR、当前读、快照读"><a href="#RC、RR、当前读、快照读" class="headerlink" title="RC、RR、当前读、快照读"></a>RC、RR、当前读、快照读</h3><p><img src="/2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/1617985687206-25965f94-99c4-4793-9b66-4702e7eb9e8f.png" alt="image.png"></p><p><img src="/2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/1618025212755-25c3ff4a-e40e-4e32-aa60-9a2a36d14872.png" alt="image.png"></p><p>MVCC实现了事务的隔离性</p><p>其他：</p><blockquote><p>原子性-&gt;undolog</p><p>一致性-&gt;代码层面</p><p>持久性-&gt;redolog </p></blockquote><h3 id="数据库一行数据"><a href="#数据库一行数据" class="headerlink" title="数据库一行数据"></a>数据库一行数据</h3><p>id  name  隐藏id  trx_id  roll_pointer </p><p><img src="/2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/1617984203206-9fe723cf-de95-444a-be15-f28b71c660cc.png" alt="image.png"></p><p>上面的rowid既是隐藏id</p><h3 id="innodb表下存在隐藏列"><a href="#innodb表下存在隐藏列" class="headerlink" title="innodb表下存在隐藏列:"></a>innodb表下存在隐藏列:</h3><p>trx_id : 存放当前事务id</p><p>roll_pointer : 存放一个指向上一事务版本的指针</p><h3 id="版本链作用"><a href="#版本链作用" class="headerlink" title="版本链作用"></a>版本链作用</h3><ol><li>用一个单链表的结构存放每个事务版本对应的行的数据; 通过我当前的事务id可以获取对应的数据</li><li>配合readView的活跃事务数组可以判断当前应该读取哪个节点的数据, 如果我当前事务不在版本链上就向前读取节点直到读取的节点ID不在活跃事务数组中, 那么这个版本的数据就是最新的已提交数据</li></ol><p>当我们存在多个历史版本的时候， 我们应该选择哪个历史版本呢？</p><p><strong>当存在多个历史版本的时候，会涉及到一个可见性算法，来计算当前事务读取的是哪一个历史版本的数据。</strong></p><p>既是<strong>ReadView</strong></p><p>ReadView是事务开启时，当前所有事务的一个集合，这个数据结构中存储了当前ReadView中最大的ID及最小的ID。</p><p>这就是当前活跃事务列表，如下所示：</p><p>ct-trx –&gt; trx11 –&gt; trx9 –&gt; trx6 –&gt; trx5 –&gt; trx3;</p><p>ct-trx 表示当前事务的id，对应上面的read_view数据结构如下，</p><p>read_view-&gt;creator_trx_id = ct-trx;</p><p>read_view-&gt;up_limit_id = trx3;</p><p>read_view-&gt;low_limit_id = trx11; </p><p>read_view-&gt;trx_ids = [trx11, trx9, trx6, trx5, trx3];</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>update；commit；</td></tr><tr><td>…</td><td>快照读</td><td>…</td><td></td></tr></tbody></table><p>问题：事务二执行快照读的时候， 能否读到事务4修改的数据？</p><p>此时：</p><p>undolog 历史版本： 1个历史版本</p><p>trx_ids  = [1, 2, 3]  生成ReadView时的活跃id（4已提交，不再活跃）</p><p>up_limit_id = 1  当前活跃id的最小值</p><p>lower_limit_id = 5  尚未分配的下一个事务id   </p><p>当前行所对应的事务db_trx_id是4（因为4最先对其进行了修改）</p><p><img src="/2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/1617985375936-cff7990e-6ded-4c88-8450-0d55c4d6d983.png" alt="image.png"></p><p>根据规则， 可见。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="/2021/04/10/mysql-bing-fa-fang-wen-de-he-xin-ji-zhi-mvcc/1617985561625-ff55b487-f9f9-458e-a38d-f003cc836b74.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL创建数据库,添加用户,用户授权实操方法</title>
      <link href="2021/04/09/mysql-chuang-jian-shu-ju-ku-tian-jia-yong-hu-yong-hu-shou-quan-shi-cao-fang-fa/"/>
      <url>2021/04/09/mysql-chuang-jian-shu-ju-ku-tian-jia-yong-hu-yong-hu-shou-quan-shi-cao-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>一、创建MySQL数据库</strong></p><p>1.创建数据库语法</p><pre><code class="line-numbers language-sql">--创建名称为“testdb”数据库，并设定编码集为utf8CREATE DATABASE IF NOT EXISTS testdb DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</code></pre><p><strong>二、创建用户</strong></p><p>1.新建用户</p><pre><code class="line-numbers language-sql"> --创建了一个名为：test 密码为：1234 的用户 create user &#39;test&#39;@&#39;localhost&#39; identified by &#39;1234&#39;;</code></pre><blockquote><p>注意：<br>此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。</p></blockquote><p>2.查询用户</p><pre><code class="line-numbers language-sql">--查询用户select user,host from mysql.user;</code></pre><p>3.删除用户</p><pre><code class="line-numbers language-sql">--删除用户“test”drop user test@localhost ;--若创建的用户允许任何电脑登陆，删除用户如下drop user test@&#39;%&#39;;</code></pre><p>4.更改密码</p><pre><code class="line-numbers language-sql">--方法1，密码实时更新；修改用户“test”的密码为“1122”set password for test =password(&#39;1122&#39;);--方法2，需要刷新；修改用户“test”的密码为“1234”update mysql.user set password=password(&#39;1234&#39;) where user=&#39;test&#39;--刷新flush privileges;</code></pre><p>5.用户分配权限</p><pre><code class="line-numbers language-sql">--授予用户test通过外网IP对数据库“testdb”的全部权限grant all privileges on &#39;testdb&#39;.* to &#39;test&#39;@&#39;%&#39; identified by &#39;1234&#39;; --刷新权限flush privileges; --授予用户“test”通过外网IP对于该数据库“testdb”中表的创建、修改、删除权限,以及表数据的增删查改权限grant create,alter,drop,select,insert,update,delete on testdb.* to test@&#39;%&#39;;   </code></pre><p>6.查看用户权限</p><pre><code class="line-numbers language-sql">--查看用户“test”show grants for test;</code></pre><blockquote><p>注意：修改完权限以后 一定要刷新服务，或者重启服务，刷新服务用：flush privileges;</p></blockquote><p>例子：</p><pre><code class="line-numbers language-sql">create user &#39;A&#39;@&#39;%&#39; identified by &#39;A&#39;;select user,host from mysql.userGrant all privileges on test_db.* to &#39;A&#39;@&#39;%&#39;;  grant create,alter,drop,select,insert,update,delete on test_db.* to A@&#39;%&#39;;flush privileges;--其他操作drop user A@&#39;%&#39;;update mysql.user set host=&#39;%&#39; where user=&#39;A&#39;;show grants for A@&#39;%&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ReadWriteLock到Java锁</title>
      <link href="2021/04/09/cong-readwritelock-dao-java-suo/"/>
      <url>2021/04/09/cong-readwritelock-dao-java-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="可重入锁详解"><a href="#可重入锁详解" class="headerlink" title="可重入锁详解"></a>可重入锁详解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</p><pre><code class="line-numbers language-java">package com.xu.lock;// 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁，synchronized和ReentrantLock都是可重入的// 可重入降低了编程复杂性public class WhatReentrant &#123;    public static void main(String[] args) &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                synchronized (this) &#123;                    System.out.println(&quot;第1次获取锁，这个锁是：&quot; + this);                    int index = 1;                    while (true) &#123;                        synchronized (this) &#123;                            System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + this);                        &#125;                        if (index == 10) &#123;                            break;                        &#125;                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617934588759-f84e34fd-e4d6-4663-9233-8f6dbe273c04.png" alt="image.png"></p><pre><code class="line-numbers language-java">package com.xu.lock;import java.util.Random;import java.util.concurrent.locks.ReentrantLock;// 演示可重入锁是什么意思public class WhatReentrant2 &#123;    public static void main(String[] args) &#123;        ReentrantLock lock = new ReentrantLock();                new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    lock.lock();                    System.out.println(&quot;第1次获取锁，这个锁是：&quot; + lock);                    int index = 1;                    while (true) &#123;                        try &#123;                            lock.lock();                            System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + lock);                                                        try &#123;                                Thread.sleep(new Random().nextInt(200));                            &#125; catch (InterruptedException e) &#123;                                e.printStackTrace();                            &#125;                                                        if (index == 10) &#123;                                break;                            &#125;                        &#125; finally &#123;                            lock.unlock();                        &#125;                    &#125;                &#125; finally &#123;                    lock.unlock();                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617934811627-3cf08b46-79c3-42e6-8dab-10073443a1c4.png" alt="image.png"></p><p>可以发现没发生死锁，可以多次获取相同的锁</p><p>可重入锁有</p><ul><li>synchronized</li><li>ReentrantLock</li></ul><h3 id="使用ReentrantLock的注意点"><a href="#使用ReentrantLock的注意点" class="headerlink" title="使用ReentrantLock的注意点"></a>使用ReentrantLock的注意点</h3><p>ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要<strong>手动释放锁</strong>，并且<strong>加锁次数和释放次数要一样</strong></p><h2 id="ReentrantReadWriteLock读写锁"><a href="#ReentrantReadWriteLock读写锁" class="headerlink" title="ReentrantReadWriteLock读写锁"></a>ReentrantReadWriteLock读写锁</h2><h3 id="读写锁简介"><a href="#读写锁简介" class="headerlink" title="读写锁简介"></a>读写锁简介</h3><p>  现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</p><p>　针对这种场景，<strong>JAVA的并发包提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong>，描述如下：</p><p>线程进入读锁的前提条件：</p><p>没有其他线程的写锁，</p><p>没有写请求或者<strong>有写请求，但调用线程和持有锁的线程是同一个。</strong></p><p>线程进入写锁的前提条件：</p><p>没有其他线程的读锁</p><p>没有其他线程的写锁</p><p>而读写锁有以下三个重要的特性：</p><p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p><p>（2）重进入：读锁和写锁都支持线程重进入。</p><p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><p>在Java同步框架AbstractQueuedSynchronizer提到了两个概念，一个是独占锁，一个是共享锁，所谓独占锁就是只能有一个线程获取到锁，其他线程必须在这个锁释放了锁之后才能竞争而获得锁。而共享锁则可以允许多个线程获取到锁。</p><h1 id><a href="#" class="headerlink" title></a></h1><h2 id="Java设计一个高性能缓存模型（两种方法）"><a href="#Java设计一个高性能缓存模型（两种方法）" class="headerlink" title="Java设计一个高性能缓存模型（两种方法）"></a>Java设计一个高性能缓存模型（两种方法）</h2><h3 id="1-缓存模型（线程不安全）"><a href="#1-缓存模型（线程不安全）" class="headerlink" title="1. 缓存模型（线程不安全）"></a>1. 缓存模型（线程不安全）</h3><pre><code class="line-numbers language-java">import java.util.HashMap;import java.util.Map;public class CacheDemo &#123;    //声明一个map,用来作为缓存模型    private static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    public  static Object getValue(String key) &#123;        Object value = map.get(key);        if (value == null) &#123;            value = &quot;abc&quot;;//这里是去数据库查询            map.put(key, value);//将数据放到缓存模型中        &#125;        return value;    &#125;&#125;</code></pre><p>从上面的代码可以看出，当10个线程同时访问的时候，会出现到数据查询次数也是10次，这样数据库访问压力大，不推荐使用</p><h3 id="2-缓存模型（线程安全）"><a href="#2-缓存模型（线程安全）" class="headerlink" title="2. 缓存模型（线程安全）"></a>2. 缓存模型（线程安全）</h3><pre><code class="line-numbers language-java">import java.util.HashMap;import java.util.Map;public class CacheDemo &#123;    //声明一个map,用来作为缓存模型    private static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    public synchronized static Object getValue(String key) &#123;        Object value = map.get(key);        if (value == null) &#123;            value = &quot;abc&quot;;//这里是去数据库查询            map.put(key, value);//将数据放到缓存模型中        &#125;        return value;    &#125;&#125;</code></pre><p>在getValue方法上加上后，10个线程同时访问的话，减少了数据库访问压力，但是出现一个情况，就是线程之间要通过排队抢锁才能进行访问 </p><h3 id="3-缓存模型（高性能）"><a href="#3-缓存模型（高性能）" class="headerlink" title="3. 缓存模型（高性能）"></a>3. 缓存模型（高性能）</h3><h4 id="3-1-通过synchronized设计"><a href="#3-1-通过synchronized设计" class="headerlink" title="3.1 通过synchronized设计"></a>3.1 通过synchronized设计</h4><pre><code class="line-numbers language-java">import java.util.HashMap;import java.util.Map;public class CacheDemo &#123;    //声明一个map,用来作为缓存模型    private static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    public static Object getValue(String key) &#123;        Object value = map.get(key);        if(value==null)&#123;            synchronized (CacheDemo.class)&#123;                if(value==null)&#123;                    value=&quot;abc&quot;;//这里是去数据库查询                    map.put(key,value);//将数据放到缓存模型中                &#125;            &#125;        &#125;        return value;    &#125;&#125;</code></pre><p> 从上面的代码设计可以看出，如果10个线程访问的数据已经存在于map中，不会出现竞争锁的情况，直接返回value，如果访问的数据不存在于map中，才会竞争锁进行数据库查询，并且只有第一个抢到锁的线程查询数据库，其他的线程拿到锁以后，发现value已经不为null了</p><h4 id="3-2-通过ReadWriteLock设计"><a href="#3-2-通过ReadWriteLock设计" class="headerlink" title="3.2 通过ReadWriteLock设计"></a>3.2 通过ReadWriteLock设计</h4><p>下面这个用的读写锁，设计思想和上面synchronized是一样的</p><pre><code class="line-numbers language-java">import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class CacheDemo &#123;    //声明一个map,用来作为缓存模型    private static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    //声明一个读写锁    private static ReadWriteLock rwl = new ReentrantReadWriteLock();          public static Object getValue(String key) &#123;        Object value = null;        try &#123;            rwl.readLock().lock();//开启读锁            value = map.get(key);            if (value == null) &#123;                try &#123;                    rwl.readLock().unlock();//关闭读锁                    rwl.writeLock().lock();//开启写锁                    if (value == null) &#123;                        value = &quot;abc&quot;;//这里是去数据库查询                        map.put(key, value);//将数据放到缓存模型中                    &#125;                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;                finally &#123;                    rwl.writeLock().unlock();//关闭写锁                    rwl.readLock().lock();//开启读锁                &#125;            &#125;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        finally &#123;            rwl.readLock().unlock();//关闭读锁        &#125;        return value;    &#125;&#125;</code></pre><h2 id="通俗易懂-悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现！"><a href="#通俗易懂-悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现！" class="headerlink" title="通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！"></a>通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！</h2><p>转载自<a href="https://zhuanlan.zhihu.com/p/71156910">https://zhuanlan.zhihu.com/p/71156910</a></p><p>网上关于Java中锁的话题可以说资料相当丰富，但相关内容总感觉是一大串术语的罗列，让人云里雾里，读完就忘。本文希望能为Java新人做一篇通俗易懂的整合，旨在消除对各种各样锁的术语的恐惧感，对每种锁的底层实现浅尝辄止，但是在需要时能够知道去查什么。</p><p>首先要打消一种想法，就是一个锁只能属于一种分类。其实并不是这样，比如一个锁可以同时是悲观锁、可重入锁、公平锁、可中断锁等等，就像一个人可以是男人、医生、健身爱好者、游戏玩家，这并不矛盾。OK，国际惯例，上干货。</p><h3 id="〇、synchronized与Lock"><a href="#〇、synchronized与Lock" class="headerlink" title="〇、synchronized与Lock"></a>〇、synchronized与Lock</h3><p>Java中有两种加锁的方式：一种是用<strong>synchronized关键字</strong>，另一种是用<strong>Lock接口</strong>的实现类。</p><p>形象地说，synchronized关键字是<strong>自动档</strong>，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要<strong>手动档</strong>了——各种Lock的实现类。</p><p>所以如果你只是想要简单的加个锁，对性能也没什么特别的要求，用synchronized关键字就足够了。自Java 5之后，才在java.util.concurrent.locks包下有了另外一种方式来实现锁，那就是Lock。也就是说，<strong>synchronized是Java语言内置的关键字，而Lock是一个接口</strong>，这个接口的实现类在代码层面实现了锁的功能，具体细节不在本文展开，有兴趣可以研究下AbstractQueuedSynchronizer类，写得可以说是牛逼爆了。</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947581977-be460e52-f8f8-4a2c-a97b-fb43af7607fa.png" alt="image">其实只需要关注三个类就可以了：ReentrantLock类、ReadLock类、WriteLock类。</p><p><strong>ReentrantLock、ReadLock、WriteLock</strong> 是Lock接口最重要的三个实现类。对应了“可重入锁”、“读锁”和“写锁”，后面会讲它们的用途。</p><p>ReadWriteLock其实是一个工厂接口，而ReentrantReadWriteLock是ReadWriteLock的实现类，它包含两个静态内部类ReadLock和WriteLock。这两个静态内部类又分别实现了Lock接口。</p><p>我们停止深究源码，仅从使用的角度看，Lock与synchronized的区别是什么？在接下来的几个小节中，我将梳理各种锁分类的概念，以及synchronized关键字、各种Lock实现类之间的区别与联系。</p><p>备注：</p><p>类的内部类</p><p>ReentrantReadWriteLock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示。</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947885762-9710cf84-e6e9-4ffc-b4ba-fe1e0c94aa75.png" alt="image"></p><p>说明：如上图所示，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类（通过构造函数传入的布尔值决定要构造哪一种Sync实例）；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。</p><h3 id="一、悲观锁与乐观锁"><a href="#一、悲观锁与乐观锁" class="headerlink" title="一、悲观锁与乐观锁"></a>一、悲观锁与乐观锁</h3><p>锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁<strong>并不是特指某个锁</strong>（Java中没有哪个Lock实现类就叫PessimisticLock或OptimisticLock），而是在并发情况下的两种不同策略。</p><p>悲观锁（Pessimistic Lock）, 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放。</p><p>乐观锁（Optimistic Lock）, 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以<strong>不会上锁，不会上锁！</strong>但是如果想要更新数据，则会在<strong>更新前检查在读取至更新这段时间别人有没有修改过这个数据</strong>。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。</p><p><strong>悲观锁阻塞事务，乐观锁回滚重试</strong>，它们各有优缺点，不要认为一种一定好于另一种。像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><h3 id="二、乐观锁的基础——CAS"><a href="#二、乐观锁的基础——CAS" class="headerlink" title="二、乐观锁的基础——CAS"></a>二、乐观锁的基础——CAS</h3><p>说到乐观锁，就必须提到一个概念：<strong>CAS</strong></p><p>什么是CAS呢？Compare-and-Swap，即<strong>比较并替换，</strong>也有叫做Compare-and-Set的，<strong>比较并设置</strong>。</p><p>1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。</p><p>2、设置：如果是，将A更新为B，结束。[<a href="https://zhuanlan.zhihu.com/p/71156910#ref_1">1]</a>如果不是，则什么都不做。</p><p>上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。</p><p>有了CAS，就可以实现一个<strong>乐观锁</strong>：</p><pre><code class="line-numbers language-java">data = 123; // 共享数据/* 更新数据的线程会进行如下操作 */flag = true;while (flag) &#123;    oldValue = data; // 保存原始数据    newValue = doSomething(oldValue);     // 下面的部分为CAS操作，尝试更新data的值    if (data == oldValue) &#123; // 比较        data = newValue; // 设置        flag = false; // 结束    &#125; else &#123;    // 啥也不干，循环重试    &#125;&#125;/*    很明显，这样的代码根本不是原子性的，   因为真正的CAS利用了CPU指令，   这里只是为了展示执行流程，本意是一样的。*/</code></pre><p>这是一个简单直观的乐观锁实现，它允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。 CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947582144-f3f2b9ca-d744-4a66-865e-91dcd53ba608.jpeg" alt="image">Java中真正的CAS操作调用的native方法</p><p>因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为<strong>无锁编程</strong>。换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！</p><h3 id="三、自旋锁"><a href="#三、自旋锁" class="headerlink" title="三、自旋锁"></a>三、自旋锁</h3><p>有一种锁叫<strong>自旋锁</strong>。所谓自旋，说白了就是一个 while(true) 无限循环。</p><p>刚刚的乐观锁就有类似的无限循环操作，那么它是自旋锁吗？</p><blockquote><p>感谢评论区<a href="https://www.zhihu.com/people/zhao-chen-77-90">养猫的虾</a>的指正。</p></blockquote><p>不是。尽管自旋与 while(true) 的操作是一样的，但还是应该将这两个术语分开。“自旋”这两个字，特指自旋锁的自旋。</p><p>然而在JDK中并没有自旋锁（SpinLock）这个类，那什么才是自旋锁呢？读完下个小节就知道了。</p><h3 id="四、synchronized锁升级：偏向锁-→-轻量级锁-→-重量级锁"><a href="#四、synchronized锁升级：偏向锁-→-轻量级锁-→-重量级锁" class="headerlink" title="四、synchronized锁升级：偏向锁 → 轻量级锁 → 重量级锁"></a>四、synchronized锁升级：偏向锁 → 轻量级锁 → 重量级锁</h3><p>前面提到，synchronized关键字就像是汽车的<strong>自动档，</strong>现在详细讲这个过程。一脚油门踩下去，synchronized会从<strong>无锁</strong>升级为<strong>偏向锁</strong>，再升级为<strong>轻量级锁</strong>，最后升级为<strong>重量级锁</strong>，就像自动换挡一样。那么自旋锁在哪里呢？这里的轻量级锁就是一种<strong>自旋锁</strong>。</p><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p><blockquote><p>感谢评论区<a href="https://www.zhihu.com/people/ding-yi-51-99">酷帅俊靓美</a>的问题：偏向锁的一个特性是，持有锁的线程在执行完同步代码块时不会释放锁。那么当第二个线程执行到这个synchronized代码块时是否一定会发生锁竞争然后升级为轻量级锁呢？线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活。<strong>如果线程A仍然存活，</strong>将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是<strong>如果判断结果是线程A不存在了</strong>，则线程B持有此偏向锁，锁不升级。还有人对此有疑惑，我之前确实没有描述清楚，但如果要展开讲，涉及到太多新概念，可以新开一篇了。更何况有些太底层的东西，我没读过源码，没有自信说自己一定是对的。其实在升级为轻量级锁之前，虚拟机会让线程A尽快在安全点挂起，然后在它的栈中“伪造”一些信息，让线程A在被唤醒之后，认为自己一直持有的是轻量级锁。如果线程A之前正在同步代码块中，那么线程B自旋等待即可。如果线程A之前不在同步代码块中，它会在被唤醒后检查到这一情况并立即释放锁，让线程B可以拿到。这部分内容我之前也没有深入研究过，如果有说的不对的，请多多指教啊！</p></blockquote><h3 id="五、可重入锁（递归锁）"><a href="#五、可重入锁（递归锁）" class="headerlink" title="五、可重入锁（递归锁）"></a>五、可重入锁（递归锁）</h3><p>可重入锁的字面意思是“可以重新进入的锁”，即<strong>允许同一个线程多次获取同一把锁</strong>。比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是<strong>可重入锁</strong>（因为这个原因可重入锁也叫做<strong>递归锁</strong>）<strong>。</strong></p><p>Java里只要以Reentrant开头命名的锁都是可重入锁，而且<strong>JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。</strong>如果你需要不可重入锁，只能自己去实现了。网上不可重入锁的实现真的很多，就不在这里贴代码了。99%的业务场景用可重入锁就可以了，剩下的1%是什么呢？我也不知道，谁可以在评论里告诉我？</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947582164-84f7c034-c756-4e95-b56c-8ac238953c99.png" alt="image">JDK提供的Lock的实现类都是可重入的</p><h3 id="六、公平锁、非公平锁"><a href="#六、公平锁、非公平锁" class="headerlink" title="六、公平锁、非公平锁"></a>六、公平锁、非公平锁</h3><p>如果多个线程申请一把<strong>公平锁</strong>，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是<strong>非公平锁</strong>，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。</p><p>对ReentrantLock类而言，通过构造函数传参<strong>可以指定该锁是否是公平锁，默认是非公平锁</strong>。一般情况下，非公平锁的吞吐量比公平锁大，如果没有特殊要求，优先使用非公平锁。</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947582159-4d30ca9e-793b-45db-8315-f8d836a5fc4d.png" alt="image">ReentrantLock构造器可以指定为公平或非公平</p><p>对于synchronized而言，它也是一种<strong>非公平锁</strong>，但是并没有任何办法使其变成公平锁。</p><h3 id="七、可中断锁"><a href="#七、可中断锁" class="headerlink" title="七、可中断锁"></a>七、可中断锁</h3><p>可中断锁，字面意思是“可以<strong>响应中断</strong>的锁”。</p><p>这里的关键是理解什么是<strong>中断</strong>。Java并没有提供任何直接中断某线程的方法，只提供了<strong>中断机制</strong>。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，Java的<strong>中断不能直接终止线程</strong>，而是需要被中断的线程自己决定怎么处理。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。[<a href="https://zhuanlan.zhihu.com/p/71156910#ref_2">2]</a></p><p>回到锁的话题上来，如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是<strong>可中断锁</strong>。</p><p>在Java中，synchronized就是<strong>不可中断锁</strong>，而Lock的实现类都是<strong>可中断锁，</strong>可以简单看下Lock接口。</p><pre><code class="line-numbers language-java">/* Lock接口 */public interface Lock &#123;    void lock(); // 拿不到锁就一直等，拿到马上返回。    void lockInterruptibly() throws InterruptedException; // 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。    boolean tryLock(); // 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 同上，可以自定义等待的时间。    void unlock();    Condition newCondition();&#125;</code></pre><h3 id="八、读写锁、共享锁、互斥锁"><a href="#八、读写锁、共享锁、互斥锁" class="headerlink" title="八、读写锁、共享锁、互斥锁"></a>八、读写锁、共享锁、互斥锁</h3><p>读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排他锁）。</p><p>看下Java里的ReadWriteLock接口，它只规定了两个方法，一个返回读锁，一个返回写锁。</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947582160-6204e421-3d0f-458b-bb08-74dc528df788.png" alt="image"></p><p>记得之前的乐观锁策略吗？所有线程随时都可以读，仅在写之前判断值有没有被更改。</p><p>读写锁其实做的事情是一样的，但是策略稍有不同。很多情况下，线程知道自己读取数据后，是否是为了更新它。那么何不在加锁的时候直接明确这一点呢？如果我读取值是为了更新它（SQL的for update就是这个意思），那么加锁的时候就直接加<strong>写锁</strong>，我持有写锁的时候别的线程无论读还是写都需要等待；如果我读取数据仅为了前端展示，那么加锁时就明确地加一个<strong>读锁，</strong>其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）。</p><p>虽然读写锁感觉与乐观锁有点像，但是<strong>读写锁是悲观锁策略</strong>。因为读写锁并没有在<strong>更新前</strong>判断值有没有被修改过，而是在<strong>加锁前</strong>决定应该用读锁还是写锁。乐观锁特指无锁编程，如果仍有疑惑可以再回到第一、二小节，看一下什么是“乐观锁”。</p><p>JDK提供的唯一一个ReadWriteLock接口实现类是ReentrantReadWriteLock。看名字就知道，它不仅提供了读写锁，而是都是可重入锁。 除了两个接口方法以外，ReentrantReadWriteLock还提供了一些便于外界监控其内部工作状态的方法，这里就不一一展开。</p><h3 id="九、回到悲观锁和乐观锁"><a href="#九、回到悲观锁和乐观锁" class="headerlink" title="九、回到悲观锁和乐观锁"></a>九、回到悲观锁和乐观锁</h3><blockquote><p>这篇文章经历过一次修改，我之前认为偏向锁和轻量级锁是乐观锁，重量级锁和Lock实现类为悲观锁，网上很多资料对这些概念的表述也很模糊，各执一词。</p></blockquote><p>先抛出我的结论：</p><p>我们在Java里使用的各种锁，<strong>几乎全都是悲观锁</strong>。synchronized从偏向锁、轻量级锁到重量级锁，全是悲观锁。JDK提供的Lock实现类全是悲观锁。其实只要有“锁对象”出现，那么就一定是悲观锁。因为<strong>乐观锁不是锁，而是一个在循环里尝试CAS的算法。</strong></p><p>那JDK并发包里到底有没有乐观锁呢？</p><p>有。java.util.concurrent.atomic包里面的<strong>原子类</strong>都是利用乐观锁实现的。</p><p><img src="/2021/04/09/cong-readwritelock-dao-java-suo/1617947582180-c1250e5b-dbf4-40d7-8189-2f4e535059f5.png" alt="image"></p><p>原子类AtomicInteger的自增方法为乐观锁策略</p><p>为什么网上有些资料认为偏向锁、轻量级锁是乐观锁？理由是它们底层用到了CAS？或者是把“乐观/悲观”与“轻量/重量”搞混了？其实，线程在抢占这些锁的时候，确实是循环+CAS的操作，感觉好像是乐观锁。但问题的关键是，我们说一个锁是悲观锁还是乐观锁，总是应该站在应用层，看它们是如何锁住应用数据的，而不是站在底层看抢占锁的过程。如果一个线程尝试获取锁时，发现已经被占用，它是否继续读取数据，等后续要更新时再决定要不要重试？对于偏向锁、轻量级锁来说，显然答案是否定的。无论是挂起还是忙等，对应用数据的读取操作都被“挡住”了。从这个角度看，它们确实是悲观锁。</p><p>退一步讲，也没有必要在这些术语上狠钻牛角尖，最重要的是理解它们的运行机制。想写得尽量简单一些，却发现洋洋洒洒近万字，只讲了个皮毛。深知自己水平有限，不敢保证完全正确，只能说路漫漫其修远兮，望指正。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="2021/04/01/docker-chang-yong-ming-ling/"/>
      <url>2021/04/01/docker-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>进入容器</p><pre><code class="line-numbers language-shell">docker exec -it mysql bin/bash</code></pre><p>容器数据卷挂载示例</p><pre><code class="line-numbers language-shell">docker run -p 3306:3306 --name mysql \-v /mydata/mysql/log:/var/log/mysql \-v /mydata/mysql/data:/var/lib/mysql \-v /mydata/mysql/conf:/etc/mysql \-v /mydata/mysql/mysql-files:/var/lib/mysql-files \-e MYSQL_ROOT_PASSWORD=root \-d mysql:5.7</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="2021/04/01/jvm/"/>
      <url>2021/04/01/jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="/2021/04/01/jvm/image-20210409140844624.png" alt="image-20210409140844624"></p><h2 id="一个对象从出生到消亡的过程"><a href="#一个对象从出生到消亡的过程" class="headerlink" title="一个对象从出生到消亡的过程"></a>一个对象从出生到消亡的过程</h2><p><img src="/2021/04/01/jvm/image-20210403155305061.png" alt="image-20210403155305061"></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Nginx 部署前后端分离项目，解决跨域问题</title>
      <link href="2021/03/28/shi-yong-nginx-bu-shu-qian-hou-duan-fen-chi-xiang-mu-jie-jue-kua-yu-wen-ti/"/>
      <url>2021/03/28/shi-yong-nginx-bu-shu-qian-hou-duan-fen-chi-xiang-mu-jie-jue-kua-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Nginx-部署前后端分离项目，解决跨域问题"><a href="#使用-Nginx-部署前后端分离项目，解决跨域问题" class="headerlink" title="使用 Nginx 部署前后端分离项目，解决跨域问题"></a>使用 Nginx 部署前后端分离项目，解决跨域问题</h1><h3 id="1-不得不说的跨域"><a href="#1-不得不说的跨域" class="headerlink" title="1 不得不说的跨域"></a>1 不得不说的跨域</h3><p>很多人对前后端分离部署感到困惑，其实主要是困惑跨域问题怎么解决。因为前后端分离项目在开发的时候，前端通过 nodejs 来运行，需要一个单独的端口，后端通过 Tomcat 或者 Jetty 来运行，也需要端口，两个不同的端口，就造成了跨域。</p><p>但是松哥之前多次和大家聊过这个问题，这种跨域并不是我们传统开发中真正的跨域，这个所谓的跨域只在开发环境中存在，生产环境下就不存在这个跨域问题了。所以我们不能按照以往的通过 JSONP 或者 CORS 之类的手段来解决这个跨域问题。</p><p>前后端分离开发中，前端为了能够模拟出测试数据，并且模拟出请求，一般需要借助于 nodejs 来运行，这是开发时候的状态，开发时候的配置大家可以参考这篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/szgfT3tnYMCHSeiE3_QnpA">前后端分离历险记</a></li></ul><p>等开发完成后，我们会对前端项目编译打包，编译打包完成之后，就只剩下一堆 js、css 以及 html 文件了，我们把这些编译打包后的文件拷贝到后端项目中，这样再去运行就不存在跨域问题了（例如将编译打包后的静态文件拷贝到 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）。这种方式我就不再多说了，相信大家都会，今天咱们主要来看看如何结合 Nginx 来部署。</p><h3 id="2-Nginx-大杀器"><a href="#2-Nginx-大杀器" class="headerlink" title="2 Nginx 大杀器"></a>2 Nginx 大杀器</h3><p>结合 Nginx 来部署前后端分离项目算是目前的主流方案。一来部署方便，二来通过动静分离也可以有效提高项目的运行效率。</p><p>大家知道我们项目中的资源包含动态资源和静态资源两种，其中：</p><ul><li>动态资源就是那些需要经过容器处理的资源，例如 jsp、freemarker、各种接口等。</li><li>静态资源则是那些不需要经过容器处理，收到客户端请求就可以直接返回的资源，像 js、css、html 以及各种格式的图片，都属于静态资源。</li></ul><p>将动静资源分开部署，可以有效提高静态资源的加载速度以及整个系统的运行效率。</p><p>在前后端分离项目部署中，我们用 Nginx 来做一个反向代理服务器，它既可以代理动态请求，也可以直接提供静态资源访问。我们来一起看下。建议大家先阅读松哥以前关于 Nginx 的一篇旧文，可以有效帮助大家理解后面的配置：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ">Nginx 极简入门教程！</a></li></ul><h4 id="2-1-后端部署"><a href="#2-1-后端部署" class="headerlink" title="2.1 后端部署"></a>2.1 后端部署</h4><p>后端接口的部署，主要看项目的形式，如果就是普通的 SSM 项目，那就提前准备好 Tomcat ，在 Tomcat 中部署项目，如果是 Spring Boot 项目，可以通过命令直接启动 jar，如果是微服务项目，存在多个 jar 的话，可以结合 Docker 来部署（参考<a href="https://mp.weixin.qq.com/s/vSCQLvQBYMYoPhdlO2v3XA">一键部署 Spring Boot 到远程 Docker 容器</a>），无论是那种形式，对于我们 Java 工程师来说，这都不是问题，我相信这一步大家都能搞定。</p><p>后端项目可以在一个非 80 端口上部署，部署成功之后，因为这个后端项目只是提供接口，所以我们并不会直接去访问他。而是通过 Nginx 请求转发来访问这个后端接口。</p><p>松哥这里以我去年为一个律所的小程序为例，后端是一个 Spring Boot 工程，那么我可以通过 Docker 部署，也可以直接通过命令来启动，这里简单点，直接通过命令来启动 jar ，如下：</p><pre><code class="line-numbers language-shell">nohup java -jar jinlu.jar &gt; vhr.log &amp;</code></pre><p>后端启动成功之后，我并不急着直接去访问后端，而是安装并且去配置一个 Nginx，通过 Nginx 来转发请求，Nginx 的基本介绍与安装，大家可以参考（<a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ">Nginx 极简入门教程！</a>），我这里就直接来说相关的配置了。</p><p>这里我们在 nginx.conf 中做出如下配置：</p><p>首先配置上游服务器：</p><pre><code class="line-numbers language-shell">upstream zqq.com&#123;  server 127.0.0.1:9999 weight=2;&#125;</code></pre><p>在这里主要是配置服务端的地址，如果服务端是集群化部署，那么这里就会有多个服务端地址，然后可以通过权重或者 ip hash 等方式进行请求分发。</p><p>然后我们在 server 中配置转发规则：</p><pre><code class="line-numbers language-shell">location /jinlu/ &#123;  proxy_pass http://zqq.com;  tcp_nodelay     on;  proxy_set_header Host            $host;  proxy_set_header X-Real-IP       $remote_addr;  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;</code></pre><p>这样配置完成后，假设我目前的域名是 javaboy.org，那么用户通过 <code>http://www.javaboy.org/jinlu/**</code> 格式的地址就可以访问到我服务端的接口。</p><h4 id="2-2-前端部署"><a href="#2-2-前端部署" class="headerlink" title="2.2 前端部署"></a>2.2 前端部署</h4><p>以 Vue 为例，如果是 SPA 应用，项目打包之后，就是一个 index.html 还有几个 js、css、images 以及 fonts ，这些都是静态文件，我们将静态文件首先上传到服务器，然后在 nginx.conf 中配置静态资源访问，具体配置如下：</p><pre><code class="line-numbers language-shell">location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) &#123;   root /usr/local/nginx/html/;#所有静态文件直接读取硬盘   expires 30d; #缓存30天&#125; </code></pre><p>当然我这里是按照资源类型来拦截的，即后缀为 js、css、ico 等的文件，统统都不进行请求分发，直接从本地的 /usr/local/nginx/html/ 目录下读取并返回到前端（我们需要将静态资源文件上传到 <code>/usr/local/nginx/html/</code> 目录下）。</p><p>如果我们的服务器上部署了多个项目，这种写法就不太合适，因为多个项目的前端静态文件肯定要分门别类，各自放好的，这个时候我们一样可以通过路径来拦截，配置如下：</p><pre><code class="line-numbers language-shell">location /jinlu-admin/ &#123;   root /usr/local/nginx/html/jinlu-admin/;#所有静态文件直接读取硬盘   expires 30d; #缓存30天&#125; </code></pre><p>这样，请求路径是 /jinlu-admin/ 格式的请求，则不会进行请求分发，而是直接从本机的 <code>/usr/local/nginx/html/jinlu-admin/</code> 目录下返回相关资源。采用这方方式配置静态资源，我们就可以部署多个项目了，多个项目的部署方式和上面的一样。</p><p>这样部署完成之后，假设我的域名是 javaboy.org ，那么用户通过 <code>http://www.javaboy.org/jinlu-admin/**</code> 格式的请求就可以访问到前端资源了。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vhr-微人事</title>
      <link href="2021/03/27/vhr-wei-ren-shi/"/>
      <url>2021/03/27/vhr-wei-ren-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><p>项目地址+部署教程：<a href="https://github.com/lenve/vhr">https://github.com/lenve/vhr</a></p><h3 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h3><ol><li><p>进入命令行模式</p><pre><code class="line-numbers language-cmd">cmd G:\Environment\redis6</code></pre></li><li><p>启动Redis</p><pre><code class="line-numbers language-cmd">redis-server.exe redis.conf</code></pre></li></ol><h3 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h3><ol><li><p>查看运行状态</p><pre><code class="line-numbers language-cmd">rabbitmqctl status</code></pre></li><li><p>运行</p><pre><code class="line-numbers language-cmd">rabbitmq-server.bat</code></pre></li><li><p>启动成功访问地址<a href="http://localhost:15672/">http://localhost:15672</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Vue </tag>
            
            <tag> Redis </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC执行流程</title>
      <link href="2021/03/19/springmvc/"/>
      <url>2021/03/19/springmvc/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h3><p><strong>原理如下图所示：</strong></p><p><img src="/2021/03/19/springmvc/image-20210409141121687.png" alt="image-20210409141121687"></p><p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基本指令练习</title>
      <link href="2021/03/17/shu-ju-ku-ji-ben-zhi-ling-lian-xi/"/>
      <url>2021/03/17/shu-ju-ku-ji-ben-zhi-ling-lian-xi/</url>
      
        <content type="html"><![CDATA[<p>收集整理来自<a href="https://www.w3schools.com/sql/exercise.asp">https://www.w3schools.com/sql/exercise.asp</a></p><h2 id="SQL-Select"><a href="#SQL-Select" class="headerlink" title="SQL Select"></a>SQL Select</h2><h3 id="1-Insert-the-missing-statement-to-get-all-the-columns-from-the-Customers-table"><a href="#1-Insert-the-missing-statement-to-get-all-the-columns-from-the-Customers-table" class="headerlink" title="1.Insert the missing statement to get all the columns from the Customers table."></a>1.Insert the missing statement to get all the columns from the <code>Customers</code> table.</h3><pre><code class="line-numbers language-sql"> SELECT * FROM Customers;</code></pre><h3 id="2-Write-a-statement-that-will-select-the-City-column-from-the-Customers-table"><a href="#2-Write-a-statement-that-will-select-the-City-column-from-the-Customers-table" class="headerlink" title="2.Write a statement that will select the City column from the Customers table."></a>2.Write a statement that will select the <code>City</code> column from the <code>Customers</code> table.</h3><pre><code class="line-numbers language-sql">SELECT City FROM Customers;</code></pre><h3 id="3-Select-all-the-different-values-from-the-Country-column-in-the-Customers-table"><a href="#3-Select-all-the-different-values-from-the-Country-column-in-the-Customers-table" class="headerlink" title="3.Select all the different values from the Country column in the Customers table."></a>3.Select all the <em>different</em> values from the <code>Country</code> column in the <code>Customers</code> table.</h3><pre><code class="line-numbers language-sql">SELECT DISTINCT Country FROM Customers;</code></pre><h2 id="SQL-Where"><a href="#SQL-Where" class="headerlink" title="SQL Where"></a>SQL Where</h2><h3 id="1-Select-all-records-where-the-City-column-has-the-value-“Berlin”"><a href="#1-Select-all-records-where-the-City-column-has-the-value-“Berlin”" class="headerlink" title="1.Select all records where the City column has the value “Berlin”."></a>1.Select all records where the <code>City</code> column has the value “Berlin”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City = &#39;Berlin&#39;;</code></pre><h3 id="2-Use-the-NOT-keyword-to-select-all-records-where-City-is-NOT-“Berlin”"><a href="#2-Use-the-NOT-keyword-to-select-all-records-where-City-is-NOT-“Berlin”" class="headerlink" title="2.Use the NOT keyword to select all records where City is NOT “Berlin”."></a>2.Use the <code>NOT</code> keyword to select all records where <code>City</code> is NOT “Berlin”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE NOT City = &#39;Berlin&#39;;</code></pre><h3 id="3-Select-all-records-where-the-CustomerID-column-has-the-value-32"><a href="#3-Select-all-records-where-the-CustomerID-column-has-the-value-32" class="headerlink" title="3.Select all records where the CustomerID column has the value 32."></a>3.Select all records where the <code>CustomerID</code> column has the value 32.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE CustomerID =32;</code></pre><h3 id="4-Select-all-records-where-the-City-column-has-the-value-‘Berlin’-and-the-PostalCode-column-has-the-value-12209"><a href="#4-Select-all-records-where-the-City-column-has-the-value-‘Berlin’-and-the-PostalCode-column-has-the-value-12209" class="headerlink" title="4.Select all records where the City column has the value ‘Berlin’ and the PostalCode column has the value 12209."></a>4.Select all records where the <code>City</code> column has the value ‘Berlin’ <em>and</em> the <code>PostalCode</code> column has the value 12209.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City = &#39;Berlin&#39;AND PostalCode = 12209;</code></pre><h3 id="5-Select-all-records-where-the-City-column-has-the-value-‘Berlin’-or-‘London’"><a href="#5-Select-all-records-where-the-City-column-has-the-value-‘Berlin’-or-‘London’" class="headerlink" title="5.Select all records where the City column has the value ‘Berlin’ or ‘London’."></a>5.Select all records where the <code>City</code> column has the value ‘Berlin’ or ‘London’.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City = &#39;Berlin&#39;OR City  = &#39;London&#39;;</code></pre><h2 id="SQL-Order-by"><a href="#SQL-Order-by" class="headerlink" title="SQL Order by"></a>SQL Order by</h2><h3 id="1-Select-all-records-from-the-Customers-table-sort-the-result-alphabetically-by-the-column-City"><a href="#1-Select-all-records-from-the-Customers-table-sort-the-result-alphabetically-by-the-column-City" class="headerlink" title="1.Select all records from the Customers table, sort the result alphabetically by the column City."></a>1.Select all records from the <code>Customers</code> table, sort the result alphabetically by the column <code>City</code>.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersORDER BY City;</code></pre><h3 id="2-Select-all-records-from-the-Customers-table-sort-the-result-reversed-alphabetically-by-the-column-City"><a href="#2-Select-all-records-from-the-Customers-table-sort-the-result-reversed-alphabetically-by-the-column-City" class="headerlink" title="2.Select all records from the Customers table, sort the result reversed alphabetically by the column City."></a>2.Select all records from the <code>Customers</code> table, sort the result <em>reversed</em> alphabetically by the column <code>City</code>.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersORDER BY City = DESC;</code></pre><h3 id="3-Select-all-records-from-the-Customers-table-sort-the-result-alphabetically-first-by-the-column-Country-then-by-the-column-City"><a href="#3-Select-all-records-from-the-Customers-table-sort-the-result-alphabetically-first-by-the-column-Country-then-by-the-column-City" class="headerlink" title="3.Select all records from the Customers table, sort the result alphabetically, first by the column Country, then, by the column City."></a>3.Select all records from the <code>Customers</code> table, sort the result alphabetically, first by the column <code>Country</code>, then, by the column <code>City</code>.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersORDER BY Country, City;</code></pre><h2 id="SQL-Insert"><a href="#SQL-Insert" class="headerlink" title="SQL Insert"></a>SQL Insert</h2><p>Insert a new record in the <code>Customers</code> table.</p><pre><code class="line-numbers language-sql">INSERT INTO Customers (CustomerName, Address, City, PostalCode,Country)VALUES(&#39;Hekkan Burger&#39;,&#39;Gateveien 15&#39;,&#39;Sandnes&#39;,&#39;4306&#39;,&#39;Norway&#39;);</code></pre><h2 id="SQL-Null"><a href="#SQL-Null" class="headerlink" title="SQL Null"></a>SQL Null</h2><h3 id="1-Select-all-records-from-the-Customers-where-the-PostalCode-column-is-empty"><a href="#1-Select-all-records-from-the-Customers-where-the-PostalCode-column-is-empty" class="headerlink" title="1.Select all records from the Customers where the PostalCode column is empty."></a>1.Select all records from the <code>Customers</code> where the <code>PostalCode</code> column is empty.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE PostalCode IS NULL;</code></pre><h3 id="2-Select-all-records-from-the-Customers-where-the-PostalCode-column-is-NOT-empty"><a href="#2-Select-all-records-from-the-Customers-where-the-PostalCode-column-is-NOT-empty" class="headerlink" title="2.Select all records from the Customers where the PostalCode column is NOT empty."></a>2.Select all records from the <code>Customers</code> where the <code>PostalCode</code> column is NOT empty.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE PostalCode IS NOT NULL;</code></pre><h2 id="SQL-Update"><a href="#SQL-Update" class="headerlink" title="SQL Update"></a>SQL Update</h2><h3 id="1-Update-the-City-column-of-all-records-in-the-Customers-table"><a href="#1-Update-the-City-column-of-all-records-in-the-Customers-table" class="headerlink" title="1.Update the City column of all records in the Customers table."></a>1.Update the <code>City</code> column of all records in the <code>Customers</code> table.</h3><pre><code class="line-numbers language-sql">UPDATE CustomersSET City = &#39;Oslo&#39;;</code></pre><h3 id="2-Set-the-value-of-the-City-columns-to-‘Oslo’-but-only-the-ones-where-the-Country-column-has-the-value-“Norway”"><a href="#2-Set-the-value-of-the-City-columns-to-‘Oslo’-but-only-the-ones-where-the-Country-column-has-the-value-“Norway”" class="headerlink" title="2.Set the value of the City columns to ‘Oslo’, but only the ones where the Country column has the value “Norway”."></a>2.Set the value of the <code>City</code> columns to ‘Oslo’, but only the ones where the <code>Country</code> column has the value “Norway”.</h3><pre><code class="line-numbers language-sql">UPDATE CustomersSET City = &#39;Oslo&#39;WHERE Country = &#39;Norway&#39;;</code></pre><h3 id="3-Update-the-City-value-and-the-Country-value"><a href="#3-Update-the-City-value-and-the-Country-value" class="headerlink" title="3.Update the City value and the Country value."></a>3.Update the <code>City</code> value <em>and</em> the <code>Country</code> value.</h3><pre><code class="line-numbers language-sql">UPDATE CustomersSET City = &#39;Oslo&#39;Country = &#39;Norway&#39;WHERE CustomerID = 32;</code></pre><h2 id="SQL-Delete"><a href="#SQL-Delete" class="headerlink" title="SQL  Delete"></a>SQL  Delete</h2><h3 id="1-Delete-all-the-records-from-the-Customers-table-where-the-Country-value-is-‘Norway’"><a href="#1-Delete-all-the-records-from-the-Customers-table-where-the-Country-value-is-‘Norway’" class="headerlink" title="1.Delete all the records from the Customers table where the Country value is ‘Norway’."></a>1.Delete all the records from the <code>Customers</code> table where the <code>Country</code> value is ‘Norway’.</h3><pre><code class="line-numbers language-sql">DELETE FROM CustomersWHERE Country = &#39;Norway&#39;;</code></pre><h3 id="2-Delete-all-the-records-from-the-Customers-table"><a href="#2-Delete-all-the-records-from-the-Customers-table" class="headerlink" title="2.Delete all the records from the Customers table."></a>2.Delete all the records from the <code>Customers</code> table.</h3><pre><code class="line-numbers language-sql">DELETE FROM Customers;</code></pre><h2 id="SQL-Functions"><a href="#SQL-Functions" class="headerlink" title="SQL Functions"></a>SQL Functions</h2><h3 id="1-Use-the-MIN-function-to-select-the-record-with-the-smallest-value-of-the-Price-column"><a href="#1-Use-the-MIN-function-to-select-the-record-with-the-smallest-value-of-the-Price-column" class="headerlink" title="1.Use the MIN function to select the record with the smallest value of the Price column."></a>1.Use the <code>MIN</code> function to select the record with the smallest value of the <code>Price</code> column.</h3><pre><code class="line-numbers language-sql">SELECT MIN(Price)FROM Products;</code></pre><h3 id="2-Use-an-SQL-function-to-select-the-record-with-the-highest-value-of-the-Price-column"><a href="#2-Use-an-SQL-function-to-select-the-record-with-the-highest-value-of-the-Price-column" class="headerlink" title="2.Use an SQL function to select the record with the highest value of the Price column."></a>2.Use an SQL function to select the record with the highest value of the <code>Price</code> column.</h3><pre><code class="line-numbers language-sql">SELECT MAX(Price)FROM Products;</code></pre><h3 id="3-Use-the-correct-function-to-return-the-number-of-records-that-have-the-Price-value-set-to-18"><a href="#3-Use-the-correct-function-to-return-the-number-of-records-that-have-the-Price-value-set-to-18" class="headerlink" title="3.Use the correct function to return the number of records that have the Price value set to 18."></a>3.Use the correct function to return the number of records that have the <code>Price</code> value set to <code>18</code>.</h3><pre><code class="line-numbers language-sql">SELECT COUNT(*)FROM ProductsWHERE Price = 18;</code></pre><h3 id="4-Use-an-SQL-function-to-calculate-the-average-price-of-all-products"><a href="#4-Use-an-SQL-function-to-calculate-the-average-price-of-all-products" class="headerlink" title="4.Use an SQL function to calculate the average price of all products."></a>4.Use an SQL function to calculate the average price of all products.</h3><pre><code class="line-numbers language-sql">SELECT AVG(Price)FROM Products;</code></pre><h3 id="5-Use-an-SQL-function-to-calculate-the-sum-of-all-the-Price-column-values-in-the-Products-table"><a href="#5-Use-an-SQL-function-to-calculate-the-sum-of-all-the-Price-column-values-in-the-Products-table" class="headerlink" title="5.Use an SQL function to calculate the sum of all the Price column values in the Products table."></a>5.Use an SQL function to calculate the sum of all the <code>Price</code> column values in the <code>Products</code> table.</h3><pre><code class="line-numbers language-sql">SELECT SUM(Price)FROM Products;</code></pre><h2 id="SQL-Like"><a href="#SQL-Like" class="headerlink" title="SQL Like"></a>SQL Like</h2><h3 id="1-Select-all-records-where-the-value-of-the-City-column-starts-with-the-letter-“a”"><a href="#1-Select-all-records-where-the-value-of-the-City-column-starts-with-the-letter-“a”" class="headerlink" title="1.Select all records where the value of the City column starts with the letter “a”."></a>1.Select all records where the value of the <code>City</code> column starts with the letter “a”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;a%&#39;;</code></pre><h3 id="2-Select-all-records-where-the-value-of-the-City-column-ends-with-the-letter-“a”"><a href="#2-Select-all-records-where-the-value-of-the-City-column-ends-with-the-letter-“a”" class="headerlink" title="2.Select all records where the value of the City column ends with the letter “a”."></a>2.Select all records where the value of the <code>City</code> column <em>ends</em> with the letter “a”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;%a&#39;;</code></pre><h3 id="3-Select-all-records-where-the-value-of-the-City-column-contains-the-letter-“a”"><a href="#3-Select-all-records-where-the-value-of-the-City-column-contains-the-letter-“a”" class="headerlink" title="3.Select all records where the value of the City column contains the letter “a”."></a>3.Select all records where the value of the <code>City</code> column contains the letter “a”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;%a%&#39;;</code></pre><h3 id="4-Select-all-records-where-the-value-of-the-City-column-starts-with-letter-“a”-and-ends-with-the-letter-“b”"><a href="#4-Select-all-records-where-the-value-of-the-City-column-starts-with-letter-“a”-and-ends-with-the-letter-“b”" class="headerlink" title="4.Select all records where the value of the City column starts with letter “a” and ends with the letter “b”."></a>4.Select all records where the value of the <code>City</code> column starts with letter “a” and ends with the letter “b”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;a%b&#39;;</code></pre><h3 id="5-Select-all-records-where-the-value-of-the-City-column-does-NOT-start-with-the-letter-“a”"><a href="#5-Select-all-records-where-the-value-of-the-City-column-does-NOT-start-with-the-letter-“a”" class="headerlink" title="5.Select all records where the value of the City column does NOT start with the letter “a”."></a>5.Select all records where the value of the <code>City</code> column does NOT start with the letter “a”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City NOT LIKE &#39;a%&#39;;</code></pre><h2 id="SQL-Wildcards"><a href="#SQL-Wildcards" class="headerlink" title="SQL Wildcards"></a>SQL Wildcards</h2><h3 id="1-Select-all-records-where-the-second-letter-of-the-City-is-an-“a”"><a href="#1-Select-all-records-where-the-second-letter-of-the-City-is-an-“a”" class="headerlink" title="1.Select all records where the second letter of the City is an “a”."></a>1.Select all records where the <em>second</em> letter of the <code>City</code> is an “a”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;_a%&#39;;</code></pre><h3 id="2-Select-all-records-where-the-first-letter-of-the-City-is-an-“a”-or-a-“c”-or-an-“s”"><a href="#2-Select-all-records-where-the-first-letter-of-the-City-is-an-“a”-or-a-“c”-or-an-“s”" class="headerlink" title="2.Select all records where the first letter of the City is an “a” or a “c” or an “s”."></a>2.Select all records where the first letter of the <code>City</code> is an “a” or a “c” or an “s”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;[acs]%&#39;;</code></pre><h3 id="3-Select-all-records-where-the-first-letter-of-the-City-starts-with-anything-from-an-“a”-to-an-“f”"><a href="#3-Select-all-records-where-the-first-letter-of-the-City-starts-with-anything-from-an-“a”-to-an-“f”" class="headerlink" title="3.Select all records where the first letter of the City starts with anything from an “a” to an “f”."></a>3.Select all records where the first letter of the <code>City</code> starts with anything from an “a” to an “f”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;[a-f]%&#39;;</code></pre><h3 id="4-Select-all-records-where-the-first-letter-of-the-City-is-NOT-an-“a”-or-a-“c”-or-an-“f”"><a href="#4-Select-all-records-where-the-first-letter-of-the-City-is-NOT-an-“a”-or-a-“c”-or-an-“f”" class="headerlink" title="4.Select all records where the first letter of the City is NOT an “a” or a “c” or an “f”."></a>4.Select all records where the first letter of the <code>City</code> is NOT an “a” or a “c” or an “f”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE City LIKE &#39;[!acf]%&#39;;</code></pre><h2 id="SQL-In"><a href="#SQL-In" class="headerlink" title="SQL In"></a>SQL In</h2><h3 id="1-Use-the-IN-operator-to-select-all-the-records-where-Country-is-either-“Norway”-or-“France”"><a href="#1-Use-the-IN-operator-to-select-all-the-records-where-Country-is-either-“Norway”-or-“France”" class="headerlink" title="1.Use the IN operator to select all the records where Country is either “Norway” or “France”."></a>1.Use the <code>IN</code> operator to select all the records where <code>Country</code> is either “Norway” or “France”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE Country IN (&#39;Norway&#39;, &#39;France&#39;);</code></pre><h3 id="2-Use-the-IN-operator-to-select-all-the-records-where-Country-is-NOT-“Norway”-and-NOT-“France”"><a href="#2-Use-the-IN-operator-to-select-all-the-records-where-Country-is-NOT-“Norway”-and-NOT-“France”" class="headerlink" title="2.Use the IN operator to select all the records where Country is NOT “Norway” and NOT “France”."></a>2.Use the <code>IN</code> operator to select all the records where <code>Country</code> is NOT “Norway” and NOT “France”.</h3><pre><code class="line-numbers language-sql">SELECT * FROM CustomersWHERE Country NOT IN (&#39;Norway&#39;, &#39;France&#39;);</code></pre><h2 id="SQL-Between"><a href="#SQL-Between" class="headerlink" title="SQL Between"></a>SQL Between</h2><h3 id="1-Use-the-BETWEEN-operator-to-select-all-the-records-where-the-value-of-the-Price-column-is-between-10-and-20"><a href="#1-Use-the-BETWEEN-operator-to-select-all-the-records-where-the-value-of-the-Price-column-is-between-10-and-20" class="headerlink" title="1.Use the BETWEEN operator to select all the records where the value of the Price column is between 10 and 20."></a>1.Use the <code>BETWEEN</code> operator to select all the records where the value of the <code>Price</code> column is between 10 and 20.</h3><pre><code class="line-numbers language-sql">SELECT * FROM ProductsWHERE Price BETWEEN 10 AND 20;</code></pre><h3 id="2-Use-the-BETWEEN-operator-to-select-all-the-records-where-the-value-of-the-Price-column-is-NOT-between-10-and-20"><a href="#2-Use-the-BETWEEN-operator-to-select-all-the-records-where-the-value-of-the-Price-column-is-NOT-between-10-and-20" class="headerlink" title="2.Use the BETWEEN operator to select all the records where the value of the Price column is NOT between 10 and 20."></a>2.Use the <code>BETWEEN</code> operator to select all the records where the value of the <code>Price</code> column is NOT between 10 and 20.</h3><pre><code class="line-numbers language-sql">SELECT * FROM ProductsWHERE Price NOT BETWEEN 10 AND 20;</code></pre><h3 id="3-Use-the-BETWEEN-operator-to-select-all-the-records-where-the-value-of-the-ProductName-column-is-alphabetically-between-‘Geitost’-and-‘Pavlova’"><a href="#3-Use-the-BETWEEN-operator-to-select-all-the-records-where-the-value-of-the-ProductName-column-is-alphabetically-between-‘Geitost’-and-‘Pavlova’" class="headerlink" title="3.Use the BETWEEN operator to select all the records where the value of the ProductName column is alphabetically between ‘Geitost’ and ‘Pavlova’."></a>3.Use the <code>BETWEEN</code> operator to select all the records where the value of the <code>ProductName</code> column is alphabetically between ‘Geitost’ and ‘Pavlova’.</h3><pre><code class="line-numbers language-sql">SELECT * FROM ProductsWHERE ProductName BETWEEN &#39;Geitost&#39; AND &#39;Pavlova&#39;;</code></pre><h2 id="SQL-Alias"><a href="#SQL-Alias" class="headerlink" title="SQL Alias"></a>SQL Alias</h2><h3 id="1-When-displaying-the-Customers-table-make-an-ALIAS-of-the-PostalCode-column-the-column-should-be-called-Pno-instead"><a href="#1-When-displaying-the-Customers-table-make-an-ALIAS-of-the-PostalCode-column-the-column-should-be-called-Pno-instead" class="headerlink" title="1.When displaying the Customers table, make an ALIAS of the PostalCode column, the column should be called Pno instead."></a>1.When displaying the <code>Customers</code> table, make an ALIAS of the <code>PostalCode</code> column, the column should be called <code>Pno</code> instead.</h3><pre><code class="line-numbers language-sql">SELECT CustomerName,Address,PostalCode AS PnoFROM Customers;</code></pre><h3 id="2-When-displaying-the-Customers-table-refer-to-the-table-as-Consumers-instead-of-Customers"><a href="#2-When-displaying-the-Customers-table-refer-to-the-table-as-Consumers-instead-of-Customers" class="headerlink" title="2.When displaying the Customers table, refer to the table as Consumers instead of Customers."></a>2.When displaying the <code>Customers</code> table, refer to the table as <code>Consumers</code> instead of <code>Customers</code>.</h3><pre><code class="line-numbers language-sql">SELECT *FROM Customers AS Consumers;</code></pre><h2 id="SQL-Join"><a href="#SQL-Join" class="headerlink" title="SQL Join"></a>SQL Join</h2><h3 id="1-Insert-the-missing-parts-in-the-JOIN-clause-to-join-the-two-tables-Orders-and-Customers-using-the-CustomerID-field-in-both-tables-as-the-relationship-between-the-two-tables"><a href="#1-Insert-the-missing-parts-in-the-JOIN-clause-to-join-the-two-tables-Orders-and-Customers-using-the-CustomerID-field-in-both-tables-as-the-relationship-between-the-two-tables" class="headerlink" title="1.Insert the missing parts in the JOIN clause to join the two tables Orders and Customers, using the CustomerID field in both tables as the relationship between the two tables."></a>1.Insert the missing parts in the <code>JOIN</code> clause to join the two tables <code>Orders</code> and <code>Customers</code>, using the <code>CustomerID</code> field in both tables as the relationship between the two tables.</h3><pre><code class="line-numbers language-sql">SELECT *FROM OrdersLEFT JOIN CustomersON Orders.CustomerID = Customers.CustomerID;</code></pre><h3 id="2-Choose-the-correct-JOIN-clause-to-select-all-records-from-the-two-tables-where-there-is-a-match-in-both-tables"><a href="#2-Choose-the-correct-JOIN-clause-to-select-all-records-from-the-two-tables-where-there-is-a-match-in-both-tables" class="headerlink" title="2.Choose the correct JOIN clause to select all records from the two tables where there is a match in both tables."></a>2.Choose the correct <code>JOIN</code> clause to select all records from the two tables where there is a match in both tables.</h3><pre><code class="line-numbers language-sql">SELECT *FROM OrdersINNER JOIN CustomersON Orders.CustomerID=Customers.CustomerID;</code></pre><h3 id="3-Choose-the-correct-JOIN-clause-to-select-all-the-records-from-the-Customers-table-plus-all-the-matches-in-the-Orders-table"><a href="#3-Choose-the-correct-JOIN-clause-to-select-all-the-records-from-the-Customers-table-plus-all-the-matches-in-the-Orders-table" class="headerlink" title="3.Choose the correct JOIN clause to select all the records from the Customers table plus all the matches in the Orders table."></a>3.Choose the correct <code>JOIN</code> clause to select all the records from the <code>Customers</code> table plus all the matches in the <code>Orders</code> table.</h3><pre><code class="line-numbers language-sql">SELECT *FROM OrdersRIGHT JOIN CustomersON Orders.CustomerID=Customers.CustomerID;</code></pre><h2 id="SQL-Group-By"><a href="#SQL-Group-By" class="headerlink" title="SQL Group By"></a>SQL Group By</h2><h3 id="1-List-the-number-of-customers-in-each-country"><a href="#1-List-the-number-of-customers-in-each-country" class="headerlink" title="1.List the number of customers in each country."></a>1.List the number of customers in each country.</h3><pre><code class="line-numbers language-sql">SELECT COUNT(CustomerID),CountryFROM CustomersGROUP BY Country;</code></pre><h3 id="2-List-the-number-of-customers-in-each-country-ordered-by-the-country-with-the-most-customers-first"><a href="#2-List-the-number-of-customers-in-each-country-ordered-by-the-country-with-the-most-customers-first" class="headerlink" title="2.List the number of customers in each country, ordered by the country with the most customers first."></a>2.List the number of customers in each country, ordered by the country with the most customers first.</h3><pre><code class="line-numbers language-sql">SELECT COUNT(CustomerID),CountryFROM CustomersGROUP BY CountryORDER BY COUNT(CustomerID) DESC;</code></pre><h2 id="SQL-Database"><a href="#SQL-Database" class="headerlink" title="SQL Database"></a>SQL Database</h2><h3 id="1-Write-the-correct-SQL-statement-to-create-a-new-database-called-testDB"><a href="#1-Write-the-correct-SQL-statement-to-create-a-new-database-called-testDB" class="headerlink" title="1.Write the correct SQL statement to create a new database called testDB."></a>1.Write the correct SQL statement to create a new database called <code>testDB</code>.</h3><pre><code class="line-numbers language-sql">CREATE DATABASE testDB;</code></pre><h3 id="2-Write-the-correct-SQL-statement-to-delete-a-database-named-testDB"><a href="#2-Write-the-correct-SQL-statement-to-delete-a-database-named-testDB" class="headerlink" title="2.Write the correct SQL statement to delete a database named testDB."></a>2.Write the correct SQL statement to delete a database named <code>testDB</code>.</h3><pre><code class="line-numbers language-sql">DROP DATABASE testDB;</code></pre><h3 id="3-Write-the-correct-SQL-statement-to-create-a-new-table-called-Persons"><a href="#3-Write-the-correct-SQL-statement-to-create-a-new-table-called-Persons" class="headerlink" title="3.Write the correct SQL statement to create a new table called Persons."></a>3.Write the correct SQL statement to create a new table called <code>Persons</code>.</h3><pre><code class="line-numbers language-sql">CREATE TABLE Persons (  PersonID int,  LastName varchar(255),  FirstName varchar(255),  Address varchar(255),  City varchar(255) );</code></pre><h3 id="4-Write-the-correct-SQL-statement-to-delete-a-table-called-Persons"><a href="#4-Write-the-correct-SQL-statement-to-delete-a-table-called-Persons" class="headerlink" title="4.Write the correct SQL statement to delete a table called Persons."></a>4.Write the correct SQL statement to delete a table called <code>Persons</code>.</h3><pre><code class="line-numbers language-sql">DROP TABLE Persons;</code></pre><h3 id="5-Use-the-TRUNCATE-statement-to-delete-all-data-inside-a-table"><a href="#5-Use-the-TRUNCATE-statement-to-delete-all-data-inside-a-table" class="headerlink" title="5.Use the TRUNCATE statement to delete all data inside a table."></a>5.Use the <code>TRUNCATE</code> statement to delete all data inside a table.</h3><pre><code class="line-numbers language-sql">TRUNCATE TABLE Persons;</code></pre><h3 id="6-Add-a-column-of-type-DATE-called-Birthday"><a href="#6-Add-a-column-of-type-DATE-called-Birthday" class="headerlink" title="6.Add a column of type DATE called Birthday."></a>6.Add a column of type <code>DATE</code> called <code>Birthday</code>.</h3><pre><code class="line-numbers language-sql">ALTER TABLE PersonsADD Birthday DATE;</code></pre><h3 id="7-Delete-the-column-Birthday-from-the-Persons-table"><a href="#7-Delete-the-column-Birthday-from-the-Persons-table" class="headerlink" title="7.Delete the column Birthday from the Persons table."></a>7.Delete the column <code>Birthday</code> from the <code>Persons</code> table.</h3><pre><code class="line-numbers language-sql">ALTER TABLE PersonsDROP COLUMN Birthday;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. 解码方法-中等</title>
      <link href="2021/03/17/91-jie-ma-fang-fa-zhong-deng/"/>
      <url>2021/03/17/91-jie-ma-fang-fa-zhong-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h2><p>引用题解：<a href="https://github.com/changgyhub/leetcode_101">https://github.com/changgyhub/leetcode_101</a></p><p>加入了自己的理解</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>一共会有四种情况发生</p><ol><li><p><code>00 || [30, 40, 50, ...]</code>新来了0和前面那个一起构不成解码</p><p>合并解码和分开解码都不可</p><p>并且这两种情况都导致会出现以 0 开头的数字(00直接出现， [30, 40, 50, …]下一个来时出现)，由于没有字符映射到以 0 开头的数字，不合题意</p><p>则return 0;</p></li><li><p><code>[11, 19] || [21, 26]</code>新来了非0和前面那个一起构成解码</p><p>这两个数字有两种解码方式，即合并解码和分开解码，以11为例，可以解码为”K”或者”AA”</p><p>以22611为例</p><p>“K”可以和dp[i-2] 构成一次新的解码，即”(BZ， VF， BBF)K” =&gt;[(2 26) , (22 6), (2 2 6)]   11</p><p>“AA”可以使”A”和dp[i-1]构成一次解码，即”(BZA， VFA， BBFA)A” =&gt;[(2 26 1) , (22 6 1), (2 2 6 1)]   1</p><p>则求和：dp[i] = dp[i-2] + dp[i-1];</p></li><li><p><code>10 || 20</code> 新来了0和前面那个一起构成解码</p><p>这两个数字有一种解码方式，即合并解码，以10为例，可以解码为”J”</p><p>以22610为例</p><p>“J”可以和dp[i-2] 构成一次新的解码，即”(BZ， VF， BBF)J” =&gt;[(2 26) , (22 6), (2 2 6)]   10</p><p>则：dp[i] = dp[i-2];</p></li><li><p><code>[27, 99] </code>新来了非0和前面那个一起构不成解码</p><p>这两个数字有一种解码方式，即分开解码，以27为例，可以解码为”BG”</p><p>以22627为例</p><p>“BG”可以和dp[i-2] 构成一次新的解码，即”(BZ， VF， BBF)BG” =&gt;[(2 26) , (22 6), (2 2 6)]   27</p><p>则：dp[i] = dp[i-1];</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="line-numbers language-c++">class Solution &#123;public:    int numDecodings(string s) &#123;        int n = s.length();        if (n == 0) return 0;        int prev = s[0] - &#39;0&#39;;        if (!prev) return 0;        if (n == 1) return 1;        vector&lt;int&gt; dp(n + 1, 1);        for (int i = 2; i &lt;= n; ++i) &#123;            int cur = s[i-1] - &#39;0&#39;;            //00 || [30, 40, 50, ...]新来了0和前面那个一起构不成解码            //这都导致会出现以 0 开头的数字(00直接出现， [30, 40, 50, ...]下一个来时出现)，不合题意，return 0.            if ((prev == 0 || prev &gt; 2) &amp;&amp; cur == 0) &#123;                return 0;            &#125;            //[10, 99]            if ((prev == 1) || prev == 2 &amp;&amp; cur &lt; 7) &#123;                //[11, 19] || [21, 26]新来了非0和前面那个一起构成解码                if (cur) &#123;                    dp[i] = dp[i-2] + dp[i-1];                &#125; else &#123;//10 || 20 新来了0和前面那个一起构成解码                    dp[i] = dp[i-2];                &#125;            &#125; else &#123;    //[27, 99] 新来了非0和前面那个一起构不成解码                       dp[i] = dp[i-1];            &#125;            prev = cur;        &#125;        return dp[n];    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>413. 等差数列划分-中等</title>
      <link href="2021/03/16/413-deng-chai-shu-lie-hua-fen-zhong-deng/"/>
      <url>2021/03/16/413-deng-chai-shu-lie-hua-fen-zhong-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h2><p>引用题解：<a href="https://github.com/changgyhub/leetcode_101">https://github.com/changgyhub/leetcode_101</a></p><pre><code class="line-numbers language-c++">动态规划过程：1234：123 234  1   2            1 + 2 = 312345：123 234 345   1   2   3     1 + 2 + 3 = 6    最后为什么要对 dp 数组求和？=&gt;return accumulate(dp.begin(), dp.end(), 0);    简单分析：        123有一个 123        234有两个 234， 1234        345有三个 345， 2345， 12345    所以要求和！</code></pre><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p>输入是一个一维数组，输出是满足等差条件的连续字数组个数。</p><pre><code class="line-numbers language-c++">Input: nums = [1,2,3,4]Output: 3</code></pre><p>在这个样例中，等差数列有 [1,2,3]、[2,3,4] 和 [1,2,3,4]。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。</p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        if (n &lt; 3) return 0;        vector&lt;int&gt; dp(n, 0);        for (int i = 2; i &lt; n; ++i) &#123;            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) &#123;                dp[i] = dp[i-1] + 1;            &#125;        &#125;        return accumulate(dp.begin(), dp.end(), 0);    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198.打家劫舍-中等</title>
      <link href="2021/03/16/198-da-jia-jie-she-zhong-deng/"/>
      <url>2021/03/16/198-da-jia-jie-she-zhong-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol><li><p>动态规划 <code>dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])。</code></p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        //  dp ---0, 1, 2, 3, 4, 5 ... ---        //nums ---   0, 1, 2, 3, 4 ... ---        if (nums.empty()) return 0;        int n = nums.size();        vector&lt;int&gt; dp(n + 1, 0);        dp[1] = nums[0];        for (int i = 2; i &lt;= n; ++i) &#123;            dp[i] = max(dp[i-1], nums[i-1] + dp[i-2]);        &#125;        return dp[n];    &#125;&#125;;</code></pre></li><li><p>进行空间压缩</p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        // cur ---0, 1, 2, 3, 4, 5 ... ---        //nums ---   0, 1, 2, 3, 4 ... ---        if (nums.empty()) return 0;        int n = nums.size();        int pre1 = 0, pre2 = nums[0], cur;        for (int i = 1; i &lt; n; ++i) &#123;            cur = max(pre2, pre1 + nums[i]);            pre1 = pre2;            pre2 = cur;        &#125;        return cur;    &#125;&#125;;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70.爬楼梯-简单</title>
      <link href="2021/03/16/70-pa-lou-ti-jian-dan/"/>
      <url>2021/03/16/70-pa-lou-ti-jian-dan/</url>
      
        <content type="html"><![CDATA[<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h2><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="斐波那契数列百度百科："><a href="#斐波那契数列百度百科：" class="headerlink" title="斐波那契数列百度百科："></a>斐波那契数列百度百科：</h4><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：<code>0、1、1、2、3、5、8、13、21、34、……</code>在数学上，斐波那契数列以如下被以递推的方法定义：<code>F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）</code>在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p><h4 id="典型的斐波那契数列，采用动态规划"><a href="#典型的斐波那契数列，采用动态规划" class="headerlink" title="典型的斐波那契数列，采用动态规划"></a>典型的斐波那契数列，采用动态规划</h4><ol><li><p>数组，空间复杂度为 O(n）</p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int climbStairs(int n) &#123;        //从F(0)=1，F(1)=1，开始        // n---0、1、2、3、4、5、 6、 7、 8---        //dp---1、1、2、3、5、8、13、21、34---        if (n &lt;= 2) return n;        vector&lt;int&gt; dp(n+1, 1);        for (int i = 2; i &lt;= n; ++i) &#123;            dp[i] = dp[i-1] + dp[i-2];        &#125;        return dp[n];    &#125;&#125;;</code></pre></li><li><p>空间压缩，空间复杂度优化为 O(1) </p><pre><code class="line-numbers language-c++">class Solution &#123;public:    int climbStairs(int n) &#123;        //典型的斐波那契数列        //  n---0、1、2、3、4、5、 6、 7、 8---        //cur---1、1、2、3、5、8、13、21、34---        if (n &lt;= 2) return n;        int pre2 = 1, pre1 = 1, cur;        for (int i = 2; i &lt;= n; ++i) &#123;            cur = pre1 + pre2;            pre1 = pre2;            pre2 = cur;         &#125;        return cur;    &#125;&#125;;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="2021/03/16/linux-chang-yong-ming-ling/"/>
      <url>2021/03/16/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙命令"><a href="#防火墙命令" class="headerlink" title="防火墙命令"></a>防火墙命令</h2><pre><code class="line-numbers language-shell"># 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all # 查看全部信息firewall-cmd --list-ports # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=8080/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效</code></pre><h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><blockquote><ul><li><p>/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录一般该目录名是以用户的账号命名的。</p></li><li><p>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>/tmp：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，安装包！</p></li><li><p>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul></blockquote><h2 id="vim撤销和恢复撤销快捷键"><a href="#vim撤销和恢复撤销快捷键" class="headerlink" title="vim撤销和恢复撤销快捷键"></a>vim撤销和恢复撤销快捷键</h2><p>u是撤销你刚才做的动作</p><p>ctrl+r 是恢复你刚才撤销的动作</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker进阶</title>
      <link href="2021/03/15/docker-jin-jie/"/>
      <url>2021/03/15/docker-jin-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="1-概述（官方文档）"><a href="#1-概述（官方文档）" class="headerlink" title="1.概述（官方文档）"></a>1.概述（官方文档）</h2><blockquote><p><strong>Looking for Compose file reference?</strong> <a href="https://docs.docker.com/compose/compose-file/">Find the latest version here</a>.</p></blockquote><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases">Common Use Cases</a>.</p><p>Using Compose is basically a three-step process:</p><ol><li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li>Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/cli-command/">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li></ol><p>A <code>docker-compose.yml</code> looks like this:</p><pre><code class="line-numbers language-yml">version: &quot;3.9&quot;  # optional since v1.27.0services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code      - logvolume01:/var/log    links:      - redis  redis:    image: redisvolumes:  logvolume01: &#123;&#125;</code></pre><p>For more information about the Compose file, see the <a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a>.</p><p>Compose has commands for managing the whole lifecycle of your application:</p><ul><li>Start, stop, and rebuild services</li><li>View the status of running services</li><li>Stream the log output of running services</li><li>Run a one-off command on a service</li></ul><p>关键词提取：</p><ul><li><p>multi-container Docker applications</p></li><li><p>use a YAML file to configure</p></li><li><p>with a single command</p></li></ul><p>概括：使用yml文件通过单个命令执行多个服务、容器、应用。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><ol><li><p>官网地址 </p><pre><code class="line-numbers language-shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.28.5/docker-        compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></pre></li><li><p>国内镜像</p><pre><code class="line-numbers language-shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-        compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre></li></ol><p><img src="/2021/03/15/docker-jin-jie/image-20210315185018091.png" alt="image-20210315185018091"></p><ol start="3"><li><p>授权</p><pre><code class="line-numbers language-shell">chmod +x /usr/local/bin/docker-compose</code></pre></li><li><p>查看版本</p><pre><code class="line-numbers language-shell">docker-compose --version</code></pre></li></ol><h2 id="3-Get-started-with-Docker-Compose"><a href="#3-Get-started-with-Docker-Compose" class="headerlink" title="3.Get started with Docker Compose"></a>3.Get started with Docker Compose</h2><p><strong>官网很详细，直接跟着官网走</strong></p><p><em>Estimated reading time: 11 minutes</em></p><p>On this page you build a simple Python web application running on Docker Compose. The application uses the Flask framework and maintains a hit counter in Redis. While the sample uses Python, the concepts demonstrated here should be understandable even if you’re not familiar with it.</p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p>Make sure you have already installed both <a href="https://docs.docker.com/get-docker/">Docker Engine</a> and <a href="https://docs.docker.com/compose/install/">Docker Compose</a>. You don’t need to install Python or Redis, as both are provided by Docker images.</p><h4 id="Step-1-Setup"><a href="#Step-1-Setup" class="headerlink" title="Step 1: Setup"></a>Step 1: Setup</h4><p>Define the application dependencies.</p><ol><li><p>Create a directory for the project:</p><pre><code class="line-numbers language-shell">$ mkdir composetest$ cd composetest</code></pre></li><li><p>Create a file called <code>app.py</code> in your project directory and paste this in:</p><pre><code class="line-numbers language-shell">import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#39;redis&#39;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#39;hits&#39;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#39;/&#39;)def hello():    count = get_hit_count()    return &#39;Hello World! I have been seen &#123;&#125; times.\n&#39;.format(count)</code></pre><p>In this example, <code>redis</code> is the hostname of the redis container on the application’s network. We use the default port for Redis, <code>6379</code>.</p><blockquote><p>Handling transient errors</p><p>Note the way the <code>get_hit_count</code> function is written. This basic retry loop lets us attempt our request multiple times if the redis service is not available. This is useful at startup while the application comes online, but also makes our application more resilient if the Redis service needs to be restarted anytime during the app’s lifetime. In a cluster, this also helps handling momentary connection drops between nodes.</p></blockquote></li><li><p>Create another file called <code>requirements.txt</code> in your project directory and paste this in:</p><pre><code class="line-numbers language-shell">flaskredis</code></pre></li></ol><h4 id="Step-2-Create-a-Dockerfile"><a href="#Step-2-Create-a-Dockerfile" class="headerlink" title="Step 2: Create a Dockerfile"></a>Step 2: Create a Dockerfile</h4><p>In this step, you write a Dockerfile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself.</p><p>In your project directory, create a file named <code>Dockerfile</code> and paste the following:</p><pre><code class="line-numbers language-shell">FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtEXPOSE 5000COPY . .CMD [&quot;flask&quot;, &quot;run&quot;]</code></pre><p>This tells Docker to:</p><ul><li>Build an image starting with the Python 3.7 image.</li><li>Set the working directory to <code>/code</code>.</li><li>Set environment variables used by the <code>flask</code> command.</li><li>Install gcc and other dependencies</li><li>Copy <code>requirements.txt</code> and install the Python dependencies.</li><li>Add metadata to the image to describe that the container is listening on port 5000</li><li>Copy the current directory <code>.</code> in the project to the workdir <code>.</code> in the image.</li><li>Set the default command for the container to <code>flask run</code>.</li></ul><p>For more information on how to write Dockerfiles, see the <a href="https://docs.docker.com/develop/">Docker user guide</a> and the <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a>.</p><h4 id="Step-3-Define-services-in-a-Compose-file"><a href="#Step-3-Define-services-in-a-Compose-file" class="headerlink" title="Step 3: Define services in a Compose file"></a>Step 3: Define services in a Compose file</h4><p>Create a file called <code>docker-compose.yml</code> in your project directory and paste the following:</p><pre><code class="line-numbers language-shell">version: &quot;3.3&quot; #官方写的3.9，但是会报错，改成3.3。services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre><p>This Compose file defines two services: <code>web</code> and <code>redis</code>.</p><h4 id="Web-service"><a href="#Web-service" class="headerlink" title="Web service"></a>Web service</h4><p>The <code>web</code> service uses an image that’s built from the <code>Dockerfile</code> in the current directory. It then binds the container and the host machine to the exposed port, <code>5000</code>. This example service uses the default port for the Flask web server, <code>5000</code>.</p><h4 id="Redis-service"><a href="#Redis-service" class="headerlink" title="Redis service"></a>Redis service</h4><p>The <code>redis</code> service uses a public <a href="https://registry.hub.docker.com/_/redis/">Redis</a> image pulled from the Docker Hub registry.</p><h4 id="Step-4-Build-and-run-your-app-with-Compose"><a href="#Step-4-Build-and-run-your-app-with-Compose" class="headerlink" title="Step 4: Build and run your app with Compose"></a>Step 4: Build and run your app with Compose</h4><ol><li><p>From your project directory, start up your application by running <code>docker-compose up</code>.</p><pre><code class="line-numbers language-shell">$ docker-compose upCreating network &quot;composetest_default&quot; with the default driverCreating composetest_web_1 ...Creating composetest_redis_1 ...Creating composetest_web_1Creating composetest_redis_1 ... doneAttaching to composetest_web_1, composetest_redis_1web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)redis_1  | 1:C 17 Aug 22:11:10.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1  | 1:C 17 Aug 22:11:10.480 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just startedredis_1  | 1:C 17 Aug 22:11:10.480 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.confweb_1    |  * Restarting with statredis_1  | 1:M 17 Aug 22:11:10.483 * Running mode=standalone, port=6379.redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.web_1    |  * Debugger is active!redis_1  | 1:M 17 Aug 22:11:10.483 # Server initializedredis_1  | 1:M 17 Aug 22:11:10.483 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#39; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.web_1    |  * Debugger PIN: 330-787-903redis_1  | 1:M 17 Aug 22:11:10.483 * Ready to accept connections</code></pre><p>Compose pulls a Redis image, builds an image for your code, and starts the services you defined. In this case, the code is statically copied into the image at build time.</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001054382.png" alt="image-20210316001054382"></p></li><li><p>Enter <a href="http://localhost:5000/">http://localhost:5000/</a> in a browser to see the application running.</p><p>If you’re using Docker natively on Linux, Docker Desktop for Mac, or Docker Desktop for Windows, then the web app should now be listening on port 5000 on your Docker daemon host. Point your web browser to <a href="http://localhost:5000/">http://localhost:5000</a> to find the <code>Hello World</code> message. If this doesn’t resolve, you can also try <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000</a>.</p><p>If you’re using Docker Machine on a Mac or Windows, use <code>docker-machine ip MACHINE_VM</code> to get the IP address of your Docker host. Then, open <code>http://MACHINE_VM_IP:5000</code> in a browser.</p><p>You should see a message in your browser saying:</p><pre><code class="line-numbers language-shell">Hello World! I have been seen 1 times.</code></pre><p><img src="/2021/03/15/docker-jin-jie/quick-hello-world-1.png" alt="hello world in browser"></p></li><li><p>Refresh the page.</p><p>The number should increment.</p><pre><code class="line-numbers language-shell">Hello World! I have been seen 2 times.</code></pre><p><img src="/2021/03/15/docker-jin-jie/quick-hello-world-2.png" alt="hello world in browser"></p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001224217.png" alt="image-20210316001224217"></p></li><li><p>Switch to another terminal window, and type <code>docker image ls</code> to list local images.</p><p>Listing images at this point should return <code>redis</code> and <code>web</code>.</p><pre><code class="line-numbers language-shell">$ docker image lsREPOSITORY        TAG           IMAGE ID      CREATED        SIZEcomposetest_web   latest        e2c21aa48cc1  4 minutes ago  93.8MBpython            3.4-alpine    84e6077c7ab6  7 days ago     82.5MBredis             alpine        9d8fa9aa0e5b  3 weeks ago    27.5MB</code></pre><p>You can inspect images with <code>docker inspect &lt;tag or id&gt;</code>.</p></li><li><p>Stop the application, either by running <code>docker-compose down</code> from within your project directory in the second terminal, or by hitting CTRL+C in the original terminal where you started the app.</p></li></ol><h4 id="Step-5-Edit-the-Compose-file-to-add-a-bind-mount"><a href="#Step-5-Edit-the-Compose-file-to-add-a-bind-mount" class="headerlink" title="Step 5: Edit the Compose file to add a bind mount"></a>Step 5: Edit the Compose file to add a bind mount</h4><p>Edit <code>docker-compose.yml</code> in your project directory to add a <a href="https://docs.docker.com/storage/bind-mounts/">bind mount</a> for the <code>web</code> service:</p><pre><code class="line-numbers language-shell">version: &quot;3.9&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code    environment:      FLASK_ENV: development  redis:    image: &quot;redis:alpine&quot;</code></pre><p>The new <code>volumes</code> key mounts the project directory (current directory) on the host to <code>/code</code> inside the container, allowing you to modify the code on the fly, without having to rebuild the image. The <code>environment</code> key sets the <code>FLASK_ENV</code> environment variable, which tells <code>flask run</code> to run in development mode and reload the code on change. This mode should only be used in development.</p><h4 id="Step-6-Re-build-and-run-the-app-with-Compose"><a href="#Step-6-Re-build-and-run-the-app-with-Compose" class="headerlink" title="Step 6: Re-build and run the app with Compose"></a>Step 6: Re-build and run the app with Compose</h4><p>From your project directory, type <code>docker-compose up</code> to build the app with the updated Compose file, and run it.</p><pre><code class="line-numbers language-shell">$ docker-compose upCreating network &quot;composetest_default&quot; with the default driverCreating composetest_web_1 ...Creating composetest_redis_1 ...Creating composetest_web_1Creating composetest_redis_1 ... doneAttaching to composetest_web_1, composetest_redis_1web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)...</code></pre><p>Check the <code>Hello World</code> message in a web browser again, and refresh to see the count increment.</p><blockquote><p>Shared folders, volumes, and bind mounts</p><ul><li>If your project is outside of the <code>Users</code> directory (<code>cd ~</code>), then you need to share the drive or location of the Dockerfile and volume you are using. If you get runtime errors indicating an application file is not found, a volume mount is denied, or a service cannot start, try enabling file or drive sharing. Volume mounting requires shared drives for projects that live outside of <code>C:\Users</code> (Windows) or <code>/Users</code> (Mac), and is required for <em>any</em> project on Docker Desktop for Windows that uses <a href="https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers">Linux containers</a>. For more information, see <a href="https://docs.docker.com/docker-for-mac/#file-sharing">File sharing</a> on Docker for Mac, and the general examples on how to <a href="https://docs.docker.com/storage/volumes/">Manage data in containers</a>.</li><li>If you are using Oracle VirtualBox on an older Windows OS, you might encounter an issue with shared folders as described in this <a href="https://www.virtualbox.org/ticket/14920">VB trouble ticket</a>. Newer Windows systems meet the requirements for <a href="https://docs.docker.com/docker-for-windows/install/">Docker Desktop for Windows</a> and do not need VirtualBox.</li></ul></blockquote><h4 id="Step-7-Update-the-application"><a href="#Step-7-Update-the-application" class="headerlink" title="Step 7: Update the application"></a>Step 7: Update the application</h4><p>Because the application code is now mounted into the container using a volume, you can make changes to its code and see the changes instantly, without having to rebuild the image.</p><p>Change the greeting in <code>app.py</code> and save it. For example, change the <code>Hello World!</code> message to <code>Hello from Docker!</code>:</p><pre><code class="line-numbers language-shell">return &#39;Hello from Docker! I have been seen &#123;&#125; times.\n&#39;.format(count)</code></pre><p>Refresh the app in your browser. The greeting should be updated, and the counter should still be incrementing.</p><p><img src="/2021/03/15/docker-jin-jie/quick-hello-world-3.png" alt="hello world in browser"></p><h4 id="Step-8-Experiment-with-some-other-commands"><a href="#Step-8-Experiment-with-some-other-commands" class="headerlink" title="Step 8: Experiment with some other commands"></a>Step 8: Experiment with some other commands</h4><p>If you want to run your services in the background, you can pass the <code>-d</code> flag (for “detached” mode) to <code>docker-compose up</code> and use <code>docker-compose ps</code> to see what is currently running:</p><pre><code class="line-numbers language-shell">$ docker-compose up -dStarting composetest_redis_1...Starting composetest_web_1...$ docker-compose ps       Name                      Command               State           Ports         -------------------------------------------------------------------------------------composetest_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp              composetest_web_1     flask run                        Up      0.0.0.0:5000-&gt;5000/tcp</code></pre><p>The <code>docker-compose run</code> command allows you to run one-off commands for your services. For example, to see what environment variables are available to the <code>web</code> service:</p><pre><code class="line-numbers language-shell">$ docker-compose run web env</code></pre><p>See <code>docker-compose --help</code> to see other available commands. You can also install <a href="https://docs.docker.com/compose/completion/">command completion</a> for the bash and zsh shell, which also shows you available commands.</p><p>If you started Compose with <code>docker-compose up -d</code>, stop your services once you’ve finished with them:</p><pre><code class="line-numbers language-shell">$ docker-compose stop</code></pre><p>You can bring everything down, removing the containers entirely, with the <code>down</code> command. Pass <code>--volumes</code> to also remove the data volume used by the Redis container:</p><pre><code class="line-numbers language-shell">$ docker-compose down --volumes</code></pre><p>At this point, you have seen the basics of how Compose works.</p><h3 id="Where-to-go-next"><a href="#Where-to-go-next" class="headerlink" title="Where to go next"></a>Where to go next</h3><ul><li>Next, try the <a href="https://docs.docker.com/compose/samples-for-compose/">Sample apps with Compose</a></li><li><a href="https://docs.docker.com/compose/reference/">Explore the full list of Compose commands</a></li><li><a href="https://docs.docker.com/compose/compose-file/">Compose configuration file reference</a></li><li>To learn more about volumes and bind mounts, see <a href="https://docs.docker.com/storage/">Manage data in Docker</a></li></ul><p><a href="https://docs.docker.com/search/?q=documentation">documentation</a>, <a href="https://docs.docker.com/search/?q=docs">docs</a>, <a href="https://docs.docker.com/search/?q=docker">docker</a>, <a href="https://docs.docker.com/search/?q=compose">compose</a>, <a href="https://docs.docker.com/search/?q=orchestration">orchestration</a>, <a href="https://docs.docker.com/search/?q=containers">containers</a></p><h2 id="4-整个过程的理解："><a href="#4-整个过程的理解：" class="headerlink" title="4.整个过程的理解："></a>4.整个过程的理解：</h2><p>1、应用app.py<br>2、Dockerfile应用打包为镜像<br>3、Docker-compose yaml文件 (定义整个服务，需要的环境。web、redis)完整的上线服务!</p><p>4、启动compose 项目(docker-compose up)<br>流程:</p><p>1、创建网络<br>2、执行Docker-compose yaml</p><p>3、启动服务。<br>Docker-compose yaml<br>Creating composetest_web_1 … done    </p><p>Creating composetest_redis_1 … done</p><p>1、文件名composetest</p><p>2、服务</p><pre><code class="line-numbers language-shell">version: &quot;3.9&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre><p> 自动的默认规则?</p><pre><code class="line-numbers language-shell">docker images</code></pre><p>帮我们自动下载了</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001522283.png" alt="image-20210316001522283"></p><p>默认的服务名    文件名_服务名__num</p><p>多个服务器。集群。A B _num    副本数量</p><p>服务redis服务=&gt;4个副本。<br>集群状态。服务都不可能只有一个运行实例。弹性、10 HA高并发。kubectl service负载均衡。</p><p>3、网络规则</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001653394.png" alt="image-20210316001653394"></p><p>10个服务=&gt;项目(项目中的内容都在同个网络下。域名访问)</p><p><img src="/2021/03/15/docker-jin-jie/image-20210316001908298.png" alt="image-20210316001908298"></p><p>如果在同一个网络下，我们可以直接通过域名访问。</p><p>HA!(高可用)</p><h2 id="5-yaml规则"><a href="#5-yaml规则" class="headerlink" title="5.yaml规则"></a>5.yaml规则</h2><h3 id="docker-compose-yaml-核心！"><a href="#docker-compose-yaml-核心！" class="headerlink" title="docker-compose.yaml 核心！"></a>docker-compose.yaml 核心！</h3><pre><code class="line-numbers language-yaml"># 3层！version: &#39;&#39; # 版本service: # 服务    服务1: web        # 服务配置        images        build        network        ...    服务2: redis        # 服务配置        images        build        network        ...    ...# 其他配置 卷、网络、全局规则volumes:networks:config:</code></pre><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>一个容器可能会依赖另一个容器， 通过depends_on可以配置启动顺序</p><p><strong>即使设置了<code>depends_on</code>，那也只是控制容器开始启动的时间，不能控制容器启动完成的时间</strong></p><pre><code class="line-numbers language-yaml">version: &quot;3.9&quot;services:  web:    build: .    depends_on:      - db      - redis  redis:    image: redis  db:    image: postgres</code></pre><p>其他详情见官网：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><h2 id="6-DockerFile构建过程"><a href="#6-DockerFile构建过程" class="headerlink" title="6.DockerFile构建过程"></a>6.DockerFile构建过程</h2><p>基础知识：</p><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、#表示注释</p><p>4、每一个指令都会创建提交一个新的镜像曾，并提交！</p><p><img src="/2021/03/15/docker-jin-jie/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc" alt="img"></p><p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p><p>Docker镜像逐渐成企业交付的标准，必须要掌握！</p><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</p><h2 id="7-DockerFire的指令"><a href="#7-DockerFire的指令" class="headerlink" title="7.DockerFire的指令"></a>7.DockerFire的指令</h2><p><img src="/2021/03/15/docker-jin-jie/u=1722217816,1097532442&fm=11&gp=0.jpg" alt="img"></p><pre><code class="line-numbers language-dockerfile">FROM                # 基础镜像，一切从这里开始构建MAINTAINER            # 镜像是谁写的， 姓名+邮箱RUN                    # 镜像构建的时候需要运行的命令ADD                    # 步骤，例如tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR                # 镜像的工作目录VOLUME                # 挂载的目录EXPOSE                # 保留端口配置CMD                    # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。ENTRYPOINT            # 指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD                # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。COPY                # 类似ADD，将我们文件拷贝到镜像中ENV                    # 构建的时候设置环境变量！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo代码高亮问题解决</title>
      <link href="2021/03/15/hexo-dai-ma-gao-liang-wen-ti-jie-jue/"/>
      <url>2021/03/15/hexo-dai-ma-gao-liang-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我的个人博客采用的是闪烁之狐大佬的主题<a href="https://github.com/blinkfox/hexo-theme-matery">Matery</a></p><p>最近发现我的文章代码无法高亮，寻找原因许久，终于解决！</p><p>闪烁之狐大佬采用的代码高亮插件是<a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a>，我按照教程一步步来，但无法高亮，网上很多解决方案也试了，都没有解决问题。</p><p>最后找到一篇博客<a href="https://www.jianshu.com/p/f395d92a1110">Hexo博客：六、prism代码高亮</a>，终于解决了我的问题。</p><p>本博客主题为<a href="https://github.com/blinkfox/hexo-theme-matery">Matery</a>，上边解决问题的主题为next，不过问题不大，照葫芦画瓢，无非是文件位置和代码写法不一样。</p><p>开动！！！</p><h3 id="1-清除hexo-prism-plugin插件"><a href="#1-清除hexo-prism-plugin插件" class="headerlink" title="1. 清除hexo-prism-plugin插件"></a>1. 清除<a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a>插件</h3><ol><li><p>打开根目录下的<code>package.json</code>文件，删除</p><pre><code class="line-numbers language-shell">hexo-prism-plugin: &quot;^2.3.0&quot;,</code></pre></li><li><p>打开根目录下的<code>_config.yml</code>文件，删除</p><pre><code class="line-numbers language-shell">prism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:</code></pre></li><li><p>删除<code>node_modules</code>文件中的<code>hexo-prism-plugin</code>文件夹</p></li></ol><h3 id="2-禁用highlight"><a href="#2-禁用highlight" class="headerlink" title="2.  禁用highlight"></a>2.  禁用highlight</h3><p>打开根目录下的<code>_config.yml</code>文件，修改配置</p><pre><code class="line-numbers language-yml">highlight:  enable: false  line_number: false  auto_detect: false  tab_replace: &#39;&#39;  wrap: false  hljs: false</code></pre><h3 id="3-获取prism"><a href="#3-获取prism" class="headerlink" title="3.  获取prism"></a>3.  获取prism</h3><p>下载页面：<a href="https://links.jianshu.com/go?to=https://prismjs.com/download.html">https://prismjs.com/download.html</a>；选择 theme 主题、language 支持的语言（不要选太多，够用就好）、plugin 插件（我选的是Line Numbers、Highlight Keywords，其他的看自己需求）；然后点击下载按钮就行了；下载到本地。将他们移动到对应的的位置，它们的路径分别是：</p><pre><code class="line-numbers language-txt">项目根目录\themes\hexo-theme-matery\source\css\prism.css项目根目录\themes\hexo-theme-matery\source\js\prism.js</code></pre><h3 id="4-配置-prism"><a href="#4-配置-prism" class="headerlink" title="4.  配置 prism"></a>4.  配置 prism</h3><ol><li><p>修改<code>\themes\hexo-theme-matery\layout\_partial\footer.ejs</code>， 在尾部添加以下代码：</p><pre><code class="line-numbers language-ejs">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/prism.css&quot;&gt;</code></pre></li><li><p>修改 <code>\themes\hexo-theme-matery\layout\_partial\footer.ejs</code>，在尾部添加以下代码</p><pre><code class="line-numbers language-ejs">&lt;script src=&quot;/js/prism.js&quot; async&gt;&lt;/script&gt;    </code></pre></li></ol><h3 id="5-修改博客配置"><a href="#5-修改博客配置" class="headerlink" title="5. 修改博客配置"></a>5. 修改博客配置</h3><p>打开根目录下的<code>_config.yml</code>文件，添加下面代码</p><pre><code class="line-numbers language-yml">marked:  langPrefix: line-numbers language-</code></pre><h3 id="6-测试prism"><a href="#6-测试prism" class="headerlink" title="6.  测试prism"></a>6.  测试prism</h3><pre><code class="line-numbers language-git">hexo cleanhexo ghexo s</code></pre><p>大功告成！！！</p><p>这个问题解决了，烦心的事情又少了一件，终于可以快快乐乐的写博客了！</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>126.单词接龙 II-困难</title>
      <link href="2021/03/14/126-dan-ci-jie-long-ii-kun-nan/"/>
      <url>2021/03/14/126-dan-ci-jie-long-ii-kun-nan/</url>
      
        <content type="html"><![CDATA[<h3 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个起始字符串和一个终止字符串，以及一个单词表，求是否可以将起始字符串每次改一个字符，直到改成终止字符串，且所有中间的修改过程表示的字符串都可以在单词表里找到。</p><p>若存在，输出需要修改次数最少的所有更改方式。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入是两个字符串，输出是一个二维字符串数组，表示每种字符串修改方式。</p><pre><code class="line-numbers language-C++">Input:beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们可以把起始字符串、终止字符串、以及单词表里所有的字符串想象成节点。若两个字符串只有一个字符不同，那么它们相连。因为题目需要输出修改次数最少的所有修改方式，因此我们可以使用广度优先搜索，求得起始节点到终止节点的最短距离。</p><p>我们同时还使用了一个小技巧：我们并不是直接从起始节点进行广度优先搜索，直到找到终止节点为止；而是从起始节点和终止节点分别进行广度优先搜索，每次只延展当前层节点数最少的那一端，这样我们可以减少搜索的总结点数。举例来说，假设最短距离为 4，如果我们只从一端搜索 4 层，总遍历节点数最多是 1 + 2 + 4 + 8 + 16 = 31；而如果我们从两端各搜索两层，总遍历节点数最多只有 2 × (1 + 2 + 4) = 14。</p><p>在搜索结束后，我们还需要通过回溯法来重建所有可能的路径。</p><pre><code class="line-numbers language-C++">class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;        //ans用来存放最后的输出结果        vector&lt;vector&lt;string&gt;&gt; ans;        //dict用来以set的形式存放字典wordList        unordered_set&lt;string&gt; dict;        for (const auto&amp; w: wordList) &#123;            dict.insert(w);        &#125;        //如果字典里没有endList，直接返回结果        if (!dict.count(endWord)) &#123;            return ans;        &#125;        //删除字典里的beginWord和endWord        dict.erase(beginWord);        dict.erase(endWord);        unordered_set&lt;string&gt; q1&#123;beginWord&#125;, q2&#123;endWord&#125;;        unordered_map&lt;string, vector&lt;string&gt;&gt; next;        bool reversed = false, found = false;        while (!q1.empty()) &#123;                unordered_set &lt;string&gt; q;                for (const auto&amp; w: q1) &#123;                    string s = w;                    for (size_t i = 0; i &lt; s.size(); i++) &#123;                        char ch = s[i];                         for (int j = 0; j &lt; 26; j++) &#123;                            s[i] = j + &#39;a&#39;;                            if (q2.count(s)) &#123;                                reversed ? next[s].push_back(w) : next[w].push_back(s);                                 found = true;                            &#125;                            if (dict.count(s)) &#123;                                reversed ? next[s].push_back(w) : next[w].push_back(s);                                q.insert(s);                            &#125;                        &#125;                        s[i] = ch;                    &#125;                &#125;                if (found) &#123;                     break;                &#125;                for (const auto&amp; w: q) &#123;                    dict.erase(w);                &#125;                if (q.size() &lt;= q2.size()) &#123;                    q1 = q;                &#125; else &#123;                     reversed = !reversed;                    q1 = q2;                    q2 = q;                &#125;        &#125;        if (found) &#123;            vector&lt;string&gt; path = &#123;beginWord&#125;;            backtracking(beginWord, endWord, next, path, ans);        &#125;        return ans;    &#125;    void backtracking(const string&amp; src, const string&amp; dst, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; next, vector&lt;string&gt;&amp; path,vector&lt;vector&lt;string&gt;&gt;&amp; ans) &#123;        if (src == dst) &#123;            ans.push_back(path);            return;        &#125;        for (const auto&amp; s : next[src]) &#123;            path.push_back(s);            backtracking(s, dst, next, path, ans);            path.pop_back();        &#125;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的学习使用记录</title>
      <link href="2021/03/14/docker-de-xue-xi-shi-yong-ji-lu/"/>
      <url>2021/03/14/docker-de-xue-xi-shi-yong-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="容器数据卷使用"><a href="#容器数据卷使用" class="headerlink" title="容器数据卷使用"></a>容器数据卷使用</h2><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><pre><code class="line-numbers language-Shell">#1.启动容器mysqldocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=密码 --name mysql mysql:8.0.23#命令-d 后台运行-p 端口映射-v 卷挂载-e 环境配置-- name 容器名字#2.查看容器的信息 docker inspect 容器id </code></pre><p><img src="/2021/03/14/docker-de-xue-xi-shi-yong-ji-lu/image-20210314200223048.png" alt="image-20210314200223048"></p><pre><code class="line-numbers language-shell">-v /home/mysql/conf:/etc/mysql/conf.d     #&#39;:&#39;前面是主机内地址， &#39;:&#39;后面是docker容器内地址</code></pre><h3 id="三种挂载方式"><a href="#三种挂载方式" class="headerlink" title="三种挂载方式"></a>三种挂载方式</h3><pre><code class="line-numbers language-shell"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载-v 容器内路径            #匿名挂载-v 卷名：容器内路径          #具名挂载-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</code></pre><p>拓展</p><pre><code class="line-numbers language-shell"># 通过 -v 容器内路径： ro rw 改变读写权限ro #readonly 只读rw #readwrite 可读可写$ docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx$ docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</code></pre><h2 id="docker启动关闭删除所有的容器命令"><a href="#docker启动关闭删除所有的容器命令" class="headerlink" title="docker启动关闭删除所有的容器命令"></a>docker启动关闭删除所有的容器命令</h2><p>1、启动所有容器</p><pre><code class="line-numbers language-shell">docker start $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre><p>2、关闭所有容器</p><pre><code class="line-numbers language-shell">docker stop $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre><p>3、删除所有容器</p><pre><code class="line-numbers language-shell">docker rm $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre><p>4、删除所有镜像（慎用）</p><pre><code class="line-numbers language-shell">docker rmi $(docker images | awk &#39;&#123;print $3&#125;&#39; |tail -n +2)</code></pre><h2 id="docker启动和关闭命令"><a href="#docker启动和关闭命令" class="headerlink" title="docker启动和关闭命令"></a>docker启动和关闭命令</h2><p>docker启动       </p><pre><code class="line-numbers language-shell">systemctl start docker重启docker服务systemctl restart  docker关闭docker    systemctl stop docker查看是否启动成功docker ps -a</code></pre><h2 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h2><p>进入tomcat bin目录后</p><p>直接启动<code>./startup.sh </code><br>作为服务启动<code>nohup ./startup.sh &amp;</code><br>控制台动态输出方式启动<code> ./catalina.sh run</code> 动态地显示tomcat后台的控制台输出信息,Ctrl+C后退出并关闭服务<br>通过方式一、方式三启动的tomcat有个弊端，当客户端连接断开的时候，tomcat服务也会立即停止，通过方式二可以作为，linux服务一直运行。<br>通过方式一、方式二方式启动的tomcat，其日志会写到相应的日志文件中，而不能动态地查看tomcat控制台的输出信息与错误情况，然后还需要<code>tail -f catalina.out</code> ;Ctrl+c 退出tail命令.<br>     然后就是检测tomcat是否启动成功： <code>ps -aux | grep tomcat </code>。输出org.apache.catalina.startup.Bootstrap start说明启动成功，<code>kill    -9 进程号</code>可以杀死进程。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk 评论登录 403 问题解决</title>
      <link href="2021/02/19/gitalk-ping-lun-deng-lu-403-wen-ti-jie-jue/"/>
      <url>2021/02/19/gitalk-ping-lun-deng-lu-403-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cuiqingcai.com/30010.html">https://cuiqingcai.com/30010.html</a></p><p>博主解决问题的思路很清晰，值得学习!</p><p><a href="https://imgchr.com/i/yfzGSe"><img src="https://s3.ax1x.com/2021/02/19/yfzGSe.jpg" alt="yfzGSe.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牧羊少年的奇幻之旅</title>
      <link href="2021/02/18/mu-yang-shao-nian-qi-huan-zhi-lu/"/>
      <url>2021/02/18/mu-yang-shao-nian-qi-huan-zhi-lu/</url>
      
        <content type="html"><![CDATA[<p>高三读完这本书后写的， 现在在看又是不一样的感觉。</p><p><img src="/2021/02/18/mu-yang-shao-nian-qi-huan-zhi-lu/%E7%89%A7%E7%BE%8A%E5%B0%91%E5%B9%B4%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85%E5%B0%81%E7%9A%AE.jpg" alt="牧羊少年奇幻之旅封皮">    </p><p>​        我是一个牧羊人，重复做着同一个梦。梦里告诉我有宝藏。在撒冷之王的指引下，我踏上了寻宝之旅。</p><p>​        第一天，我的钱就全部被我信任的人骗去。我决定不再相信任何人，我疲惫至极，当我将要放弃的时候，撒冷之王的话语回荡在我的耳边：当你想要得到某种东西的时候，整个宇宙都会合力助你实现愿望。我已不再悲伤，我怀着一个念头沉重睡去——我是一个寻宝人，明天我将开始新的旅途。</p><p>​        我遇见了水晶店的主人，我助他的水晶店焕然一新，他付我报酬使我得以继续寻宝，“命中注定”，水晶店的主人送我离开时这样说。</p><p>​        我又遇见了一个英国人，我本不想与他打交道，“一切都有预兆”，他从口中吐出这几个字，我改变了想法，我决定和他一起开始这趟沙漠之旅，因为撒冷之王说过同样的话。这位英国人和我一样有使命，他一生的一半光阴都花在了炼金术上，他要去寻找一位炼金术士。</p><p>​        沙漠之旅并不容易，一路的艰苦跋涉终使我们到达了绿洲，我为绿洲带来了战争的预兆，他们将封我为顾问，我已厌倦了这趟旅途，至高的待遇诱使我留在这里。开玩笑般的我再次遇见了一个人，他使我明白，当我老之将至，站在梧桐树下回首自己度过的虚无的一生，遥想被深埋在地下的宝藏时已为时晚矣。</p><p>​        他正是炼金术士。</p><p>​        我再次开启这趟征途，种种经历让我开始尝试倾听内心的声音，我弄懂了心所耍的各种手段和花招。被逼无奈之下我开始领悟世界的语言，感悟到了爱的力量，觉悟到了这一切皆由我的双手写就。我抵达了金字塔，奋力挖掘，然而一无所获。</p><p>​        一个经过的难民在知道我挖掘的原因之后开始耻笑我说：“你真愚蠢，我也和你一样做过同样的梦，我梦到与此地有一个沙漠之隔的教堂，一个牧羊人经常在那里过夜，如果我在那里挖掘，我会找到宝藏，可我不会像你这么蠢。”</p><p>​        我感谢这个不相信梦的家伙，我找到我的宝藏了。我站起来拍拍身上的沙子，金字塔正朝我笑呢。</p><p>​        我回到了教堂，在无果树下挖掘。“老巫师”我自言自语，“你什么都知道，甚至还为我留了回来的钱，看到我衣衫褴褛的跑回来，他们都笑了，你就不能让我免遭这一切？”</p><p>​        “不能，”我听到有个声音说，“如果我告诉你这一切，那你就看不到金字塔了，它很壮美，不是吗？”</p><p>​        那分明是炼金术士的声音。<br>​                                                                    ——《牧羊少年的奇幻之旅》</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
